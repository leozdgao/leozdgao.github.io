<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Leo.Gao]]></title>
  <subtitle><![CDATA[不积跬步无以至千里]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://leozdgao.github.io/"/>
  <updated>2015-04-09T15:18:52.621Z</updated>
  <id>http://leozdgao.github.io/</id>
  
  <author>
    <name><![CDATA[Leo Gao]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[FormData对象]]></title>
    <link href="http://leozdgao.github.io/2015/04/09/FormData%E5%AF%B9%E8%B1%A1/"/>
    <id>http://leozdgao.github.io/2015/04/09/FormData对象/</id>
    <published>2015-04-09T15:18:05.000Z</published>
    <updated>2015-04-09T15:18:52.621Z</updated>
    <content type="html"><![CDATA[<p>兼容性：IE10+</p>
<p>FormData对象可以利用一些键值对来模拟表单控件的值，并在<code>XMLHttpRequest 2.0</code>中使用send方法来异步提交表单、上传文件。</p>
<p><strong>创建FormData</strong></p>
<p>通过<code>new</code>关键字调用构造器，构造器接受一个可选参数（HTMLFormElement），根据现有表单得到FormData：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> fData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line"><span class="reserved">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'my-form'</span>);</span><br><span class="line"><span class="reserved">var</span> oData = <span class="keyword">new</span> FormData(form);</span><br></pre></td></tr></table></figure>
<p><strong>为FormData添加数据</strong></p>
<p>FormData数据仅暴露出一个方法<code>append</code>，用于往FormData中追加数据，第一个参数为字符串，代表key，第二个参数为字符串、File对象或Blob对象，其他类型都会被转换为字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fData.<span class="built_in">append</span>(<span class="string">'key1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">fData.<span class="built_in">append</span>(<span class="string">'key2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">xhr.send(fData);</span><br></pre></td></tr></table></figure>
<p>当FormData中有File时，XMLHttpRequest的请求头中的<code>Content-Type</code>被自动设置为<code>multipart/form-data</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>兼容性：IE10+</p>
<p>FormData对象可以利用一些键值对来模拟表单控件的值，并在<code>XMLHttpRequest 2.0</code>中使用send方法来异步提交表单、上传文件。</p>
<p><strong>创建FormData</strong><]]>
    </summary>
    
      <category term="javascript" scheme="http://leozdgao.github.io/tags/javascript/"/>
    
      <category term="Javascript基础" scheme="http://leozdgao.github.io/categories/jsbasic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建并触发自定义事件、模拟事件]]></title>
    <link href="http://leozdgao.github.io/2015/04/09/%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%A7%A6%E5%8F%91%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E3%80%81%E6%A8%A1%E6%8B%9F%E4%BA%8B%E4%BB%B6/"/>
    <id>http://leozdgao.github.io/2015/04/09/创建并触发自定义事件、模拟事件/</id>
    <published>2015-04-09T14:49:17.000Z</published>
    <updated>2015-04-09T14:50:37.883Z</updated>
    <content type="html"><![CDATA[<p>本文介绍了创建了使用原生JavaScript API创建事件对象并模拟触发事件的方法。</p>
<p><br></p>
<h2 id="创建自定义事件对象">创建自定义事件对象</h2><p>可以通过<code>Event</code>构造器来创建一个事件对象：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">event</span> = <span class="keyword">new</span> <span class="keyword">Event</span>(<span class="string">'build'</span>);</span><br></pre></td></tr></table></figure>
<p>在IE中，虽然有Event这个构造器，但是直接用<code>new</code>来构造会抛出异常，可以使用一个更老的方法，调用<code>document.createEvent</code>来创建一个事件对象并使用<code>e.initEvent</code>来初始化这个事件对象：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">event</span> = document.createEvent(<span class="string">'Event'</span>);</span><br><span class="line"><span class="keyword">event</span>.initEvent(<span class="string">'build'</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>第二个参数代表<em>bubbles</em>，表示事件是否可冒泡。第三个参数代表<em>cancelable</em>，表示事件是否可被取消（preventDefault）。</p>
<h2 id="触发事件">触发事件</h2><p>在事件目标对象（通常是一个HTMLElement）上调用<code>dispatchEvent</code>来触发某个事件，触发的事件由传递的事件对象决定， 比如触发上面自定义好的build事件：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">event</span> = document.createEvent(<span class="string">'Event'</span>);</span><br><span class="line"><span class="keyword">event</span>.initEvent(<span class="string">'build'</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">var</span> box = document.getElementById(<span class="string">'box'</span>);</span><br><span class="line">box.dispatchEvent(<span class="keyword">event</span>);</span><br></pre></td></tr></table></figure>
<p>也可以通过这个办法来模拟事件的触发，比如模拟<code>mouseenter</code>事件：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvent'</span>);</span><br><span class="line">e.initEvent(<span class="string">'mouseenter'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="reserved">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line">box.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍了创建了使用原生JavaScript API创建事件对象并模拟触发事件的方法。</p>
<p><br></p>
<h2 id="创建自定义事件对象">创建自定义事件对象</h2><p>可以通过<code>Event</code>构造器来创建一个事件对象：</p>
<]]>
    </summary>
    
      <category term="javascript" scheme="http://leozdgao.github.io/tags/javascript/"/>
    
      <category term="Javascript基础" scheme="http://leozdgao.github.io/categories/jsbasic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ECMAScript 6新增功能——块级作用域与解构赋值]]></title>
    <link href="http://leozdgao.github.io/2015/03/23/ECMAScript-6%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://leozdgao.github.io/2015/03/23/ECMAScript-6新增功能——块级作用域与解构赋值/</id>
    <published>2015-03-23T14:15:44.000Z</published>
    <updated>2015-03-24T12:40:07.643Z</updated>
    <content type="html"><![CDATA[<p>根据<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门</a>学习了ES6的一些新特性，在io.js v1.61版本进行代码测试，部分代码需要打开了<code>--harmony</code>，<code>--use_strict</code>等flag。</p>
<p>这个系列将将会有如下内容</p>
<ul>
<li>let , const以及块级作用域</li>
<li>变量的解构赋值</li>
<li>新增的方法</li>
<li>Set和Map数据结构</li>
<li>Generator函数</li>
<li>Promise对象</li>
<li>Class和Module</li>
</ul>
<a id="more"></a>
<h2 id="let_,_const以及块级作用域">let , const以及块级作用域</h2><p><em>注：以下代码需要io.js —harmony —use_strict</em></p>
<p>使用let声明的变量仅在所处的代码块中有效，即该变量处于块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>用let声明的变量不存在变量提升，也不允许在代码块中出现相同的声明，即使在let声明之前。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// ReferenceError 'a' is not defined.</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">6</span>;  <span class="comment">// Identifier 'a' is already defined.</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用let声明的变量将绑定其块级作用域，（这边不是特别清晰）可以避免在循环中声明函数时出现的隐患：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);  <span class="comment">// 输出为0-9</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果上面的例子中改为var声明，则会输出10个10。</p>
<p>const拥有和let同样的特点，并且它用于声明常量，尝试改变常量的值不会导致异常，只会默默失败。<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const <span class="literal">a</span> = <span class="number">6</span><span class="comment">;</span></span><br><span class="line"><span class="literal">a</span> = <span class="number">3</span><span class="comment">;</span></span><br><span class="line">console.log(<span class="literal">a</span>)<span class="comment">;  // 6</span></span><br></pre></td></tr></table></figure></p>
<p>用const声明的对象仅是让其对象的引用地址保持不变，无法保证其属性不发生改变，要让对象不被改变，可以在使用const声明的同时，调用方法<code>Object.freeze</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>.freeze(&#123; msg: <span class="string">"Hello world!"</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>在ES6中，函数声明时的作用域在其所处的块级作用域内。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  f();  <span class="comment">// ES5中，由于函数声明提升，输出为'I am inside!'，但在ES6中，结果为'I am outside!'</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>最后，在ES6中规定，在全局使用var或是function声明的变量都会作为全局对象的属性，但用let , const或是class声明的变量，将不会成为全局对象的属性。（这边补充下，在node.js/io.js环境下，一个模块中全局声明的变量是不会成为全局对象global的属性的，要成为其属性，需要显式地赋值）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);  <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">consoel.log(<span class="built_in">window</span>.b);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<h2 id="变量的解构赋值（Destructure）">变量的解构赋值（Destructure）</h2><p><em>注：当前版本的io.js不支持destructure</em></p>
<p>有两种解构赋值方式：数组解构和对象结构<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo, bar] = [<span class="number">1</span>, <span class="number">3</span>];  <span class="comment">// foo = 1, bar = 3</span></span><br><span class="line"><span class="keyword">var</span> [foo, [bar]] = [<span class="number">1</span>, [<span class="number">3</span>]];  <span class="comment">// foo = 1, bar = 3</span></span><br><span class="line"><span class="keyword">var</span> [,,third] = [<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"baz"</span>];  <span class="comment">// third = "baz"</span></span><br><span class="line"><span class="keyword">var</span> [head, ...tail] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; <span class="comment">// head = 1, tail = [2, 3, 4] (array spread特性)</span></span><br><span class="line"><span class="keyword">var</span> [a,b] = [<span class="number">1</span>]; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure></p>
<p>简单地说就是等号两边的模式匹配，如果匹配不成功，则变量值为<code>undefined</code>。对于数组解构，要求的是结构和顺序的匹配，而对于对象解构，要求的是结构和属性名的匹配：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> &#123;foo, bar&#125; = &#123; <span class="attribute">foo</span>: <span class="string">'aaa'</span>, <span class="attribute">bzz</span>: <span class="string">'zzz'</span> &#125; <span class="regexp">//</span> foo = <span class="string">'aaa'</span>, bzz = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p>
<p>如果变量名和属性名不一样也需要解构赋值，可以这样写：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; <span class="string">foo:</span> baz &#125; = &#123; <span class="string">foo:</span> <span class="string">'aaa'</span> &#125;;  <span class="comment">// baz = 'aaa'</span></span><br></pre></td></tr></table></figure></p>
<p>两种解构赋值的方式都可以使用默认值：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [a, <span class="variable">b=</span><span class="number">3</span>] = [<span class="number">6</span>];  // <span class="variable">a =</span> <span class="number">6</span>, <span class="variable">b =</span> <span class="number">3</span></span><br><span class="line">var &#123;foo,<span class="variable">bar=</span><span class="string">"dog"</span>&#125; = &#123;&#125;;  // <span class="variable">foo =</span> undefined, <span class="variable">bar =</span> <span class="string">"dog"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>用途：</strong>（这部分照抄了原文，觉得很有道理，不过鉴于io.js暂时不支持该特性，并未实践过如下用途）</p>
<p><strong>交换变量的值</strong><br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">x</span>, y] = <span class="list">[<span class="keyword">y</span>, x]</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>函数返回多个值</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></p>
<p><strong>函数参数的定义及设置默认值</strong>（合并了原文中的3和4）<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="keyword">function</span> (url, &#123;</span><br><span class="line">    async = true,</span><br><span class="line">    beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span><br><span class="line">    cache = true,</span><br><span class="line">    complete = <span class="keyword">function</span> () &#123;&#125;,</span><br><span class="line">    crossDomain = false,</span><br><span class="line">    global = true</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        // <span class="keyword">...</span> do stuff</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>遍历Map结构</strong><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (let [key, value] of map) &#123;</span><br><span class="line">   console.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取键名</span><br><span class="line"><span class="keyword">for</span> (let [key] of map) &#123;</span><br><span class="line">  // <span class="keyword">...</span></span><br><span class="line">&#125; </span><br><span class="line">// 获取键值</span><br><span class="line"><span class="keyword">for</span> (let [,value] of map) &#123;</span><br><span class="line">  // <span class="keyword">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>根据<a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a>学习了ES6的一些新特性，在io.js v1.61版本进行代码测试，部分代码需要打开了<code>--harmony</code>，<code>--use_strict</code>等flag。</p>
<p>这个系列将将会有如下内容</p>
<ul>
<li>let , const以及块级作用域</li>
<li>变量的解构赋值</li>
<li>新增的方法</li>
<li>Set和Map数据结构</li>
<li>Generator函数</li>
<li>Promise对象</li>
<li>Class和Module</li>
</ul>]]>
    
    </summary>
    
      <category term="ES6" scheme="http://leozdgao.github.io/tags/ES6/"/>
    
      <category term="javascript" scheme="http://leozdgao.github.io/tags/javascript/"/>
    
      <category term="Javascript基础" scheme="http://leozdgao.github.io/categories/jsbasic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript语言精粹笔记整理]]></title>
    <link href="http://leozdgao.github.io/2015/03/21/Javascript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://leozdgao.github.io/2015/03/21/Javascript语言精粹笔记整理/</id>
    <published>2015-03-21T11:36:13.000Z</published>
    <updated>2015-03-24T12:34:32.510Z</updated>
    <content type="html"><![CDATA[<p>这两天读了一下《Javascript语言精粹》一书，没有想象中的惊艳，不过在薄薄的100多页中浓缩了许多Javascript的编程技巧，值得细细品味。于是做了该笔记，算是对Javascript知识体系的一个回顾和整理，但并没有把书中的代码直接copy&amp;paste，而是对技巧的罗列，其中对继承那部分，有一些自己的理解。</p>
<a id="more"></a>
<h2 id="一些零星的技巧和知识点">一些零星的技巧和知识点</h2><p>Javascript的简单数据类型（原始类型 Primitive）包括Number、String、Boolean、null、undefined，其他所有值都是对象。</p>
<p>在Javascript内部，string以UTF-16存储，每个字符固定2个字节。</p>
<p>当一个Number以0开头时，会试着将其解释为八进制数，如果这个Number包含小数点，则会报出语法错误。</p>
<p>js中的假值（falsy）：false,0,null,undefined,’’,NaN</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">012</span> <span class="comment">// 10</span></span><br><span class="line"><span class="number">089</span> <span class="comment">// 89</span></span><br><span class="line"><span class="number">012.345</span> <span class="comment">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure>
<p><code>ParseInt</code>方法会试着解析一个整形数字</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="number">012</span>)</span></span> <span class="comment">// 10</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="number">012</span>, <span class="number">10</span>)</span></span> <span class="comment">// 10</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="number">012</span>, <span class="number">8</span>)</span></span> <span class="comment">// 8</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">"123Test"</span>)</span></span> <span class="comment">// 123</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(&#123;&#125;)</span></span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>将数字以0开头并试着将它认为是8进制数不是个好的做法，ES6中有八进制数字面量表示法：<code>0o12</code></p>
<p>下面是NaN表现出的一些奇怪行为，要检测NaN应该使用方法<code>isNaN()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">'number'</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> !== <span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"Hello"</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>for...in</code>会遍历到原型链中的元素，如果要避免遍历到原型链中的元素，可以在循环中使用<code>object.hasOwnProperty(variable)</code>来判断其是否属于原型链。</p>
<p><code>typeof</code>运算符结果的可能值有’number’、’string’、’boolean’、’undefined’、’function’和’object’。在用typeof判断数组或<code>null</code>时，将返回’object’。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.apply(arr) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNull</span><span class="params">(obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> obj === <span class="literal">null</span>; <span class="comment">// 注意要三个等号，因为undefined == null返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>||</code>与<code>&amp;&amp;</code>的妙用：</p>
<ul>
<li>对于<code>||</code>，如果第一个表达式为false，则返回第二个表达式的值，否则返回第一个表达式的值。</li>
<li>对于<code>&amp;&amp;</code>，如果第一个表达式为true，则返回第二个表达式的值，否则返回第一个表达式的值。</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = a || <span class="string">"default"</span>; <span class="comment">// 广泛被用于设置默认值</span></span><br><span class="line"><span class="keyword">var</span> b = obj &amp;&amp; obj.<span class="keyword">pro</span>; <span class="comment">// 保证访问属性时因对象为falsy指而报错</span></span><br></pre></td></tr></table></figure>
<h2 id="函数相关">函数相关</h2><p>Javascript没有块级作用域，只有函数级作用域。</p>
<p><strong>闭包</strong>：通过函数字面量创建的函数对象包含一个连到外部上下文的连接，即该函数可以访问它被创建时所处的上下文环境。</p>
<p><strong>模块</strong>：一个提供接口却隐藏状态与实现的函数或对象。</p>
<p>函数在Javascript中有4种调用模式：</p>
<p><strong>方法调用模式</strong><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject.<span class="keyword">method</span>(args); // 此时函数绑定上下文为myobject对象</span><br></pre></td></tr></table></figure></p>
<p><strong>函数调用模式</strong><br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> sum = add(<span class="number">3</span>, <span class="number">4</span>); <span class="regexp">//</span> 此时函数绑定上下文为<span class="built_in">global</span>对象(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>构造器调用模式</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(); <span class="comment">// 如果构造器函数返回值不是一个对象，则返回this</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>new</code>运算符将创建一个继承于Animal原型的对象，并在调用Animal时将该对象绑定给this。</p>
<p><strong>apply调用模式</strong><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.<span class="keyword">toString</span>.apply(obj, <span class="keyword">args</span>);</span><br></pre></td></tr></table></figure></p>
<p>一个普通的函数声明，其上下文绑定为global对象（window），在对象字面量中声明的函数，其上下文绑定为该对象。</p>
<h2 id="原型和继承相关">原型和继承相关</h2><p>原型连接尽在检索值时才会被用到，当该对象没有相应的属性值时，会试着从原型中获取。对象属性的改变不会涉及到原型对象。</p>
<p><code>delete</code>运算符不会触及原型链中的任何对象。</p>
<p><strong>伪类继承</strong>：给Function.prototype赋一个对象，可以把这个对象看作是’基类’<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"animal"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Miao"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.sayHi();</span><br></pre></td></tr></table></figure></p>
<p>这种继承方式还是挺常见的，不过给prototype赋的对象是有讲究的，如果是new一个对象，则会执行构造器，也就是说上例中我们创建的Cat对象可以从原型链上检索到name这个属性。这里我们来对比一下node.js中的util模块里的inherits方法的实现吧：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exports.inherits = <span class="function"><span class="keyword">function</span><span class="params">(ctor, superCtor)</span> </span>&#123;</span><br><span class="line">  ctor.super_ = superCtor;</span><br><span class="line">  ctor.prototype = <span class="built_in">Object</span>.create(superCtor.prototype, &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>: </span>&#123;</span><br><span class="line">      value: ctor,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在node.js的实现中，ctor.prototype的值是以superCtor的原型为原型创建的一个新对象，和上面一种的区别就在于没有执行构造器方法，也就是说如果使用这种方式的继承，Cat对象是无法从原型链上检索到name属性，只能检索到从原型链上继承来的方法。</p>
<p><strong>函数化模式</strong>：该模式并没有像伪类继承那样模仿类继承的概念，而是直接舍弃了new操作符，通过普通函数调用的方式实现继承。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Animal() &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">that</span> = &#123;&#125;;</span><br><span class="line">    <span class="literal">that</span>.name = <span class="string">"animal"</span>;</span><br><span class="line">    <span class="literal">that</span>.sayHi = <span class="keyword">function</span>() &#123; <span class="built_in">console</span>.log(Hi); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">that</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Cat(name) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">that</span> = Animal();</span><br><span class="line">    <span class="literal">that</span>.name = name || <span class="string">"Cat"</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">that</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = Cat(<span class="string">"kitty"</span>);</span><br></pre></td></tr></table></figure>
<p>这种方法不需要使用new操作符，也不涉及到原型，还可以通过各种闭包来保存私有的状态。</p>
<p>我个人还是会更倾向于写伪类继承的模式，可能是后端出身的关系，觉得其更符合我的思维方式。不过函数化模式更多是用于保存私用的状态，主要不太会用它实现继承。</p>
<p>看到过如下的一种做法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SkyScroll = <span class="function"><span class="keyword">function</span><span class="params">(opts)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SkyScroll.prototype.init(opts); &#125;</span><br><span class="line">SkyScroll.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span><span class="params">(opts)</span> </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// other methods</span></span><br><span class="line">&#125;;</span><br><span class="line">SkyScroll.prototype.init.prototype = SkyScroll.prototype;</span><br><span class="line"><span class="built_in">window</span>.SkyScroll = SkyScroll;</span><br></pre></td></tr></table></figure>
<p>这种方法说不上和继承有关系，不过有一定特点，就是不论你使用<code>var a = SkyScroll({})</code>还是用new操作符调用构造器<code>var b = new SkyScroll({})</code>返回的结果都是相同的，不会因为使用函数调用模式调用构造器而污染全局环境，使用构造器模式调用返回的为一个对象，这个对象可以被正常返回，所以这两种方式都可以成功构造一个SkyScroll对象。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天读了一下《Javascript语言精粹》一书，没有想象中的惊艳，不过在薄薄的100多页中浓缩了许多Javascript的编程技巧，值得细细品味。于是做了该笔记，算是对Javascript知识体系的一个回顾和整理，但并没有把书中的代码直接copy&amp;paste，而是对技巧的罗列，其中对继承那部分，有一些自己的理解。</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://leozdgao.github.io/tags/javascript/"/>
    
      <category term="Javascript基础" scheme="http://leozdgao.github.io/categories/jsbasic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Reset及相关思考]]></title>
    <link href="http://leozdgao.github.io/2015/03/17/CSS-Reset%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%80%9D%E8%80%83/"/>
    <id>http://leozdgao.github.io/2015/03/17/CSS-Reset及相关思考/</id>
    <published>2015-03-17T12:55:13.000Z</published>
    <updated>2015-03-21T03:14:09.719Z</updated>
    <content type="html"><![CDATA[<p>有一个专门讲CSS Reset的站点。 <a href="http://www.cssreset.com/" target="_blank" rel="external">site</a></p>
<p>由于各大浏览器的user agent样式（即默认样式）不同，为了尽可能避免浏览器之间样式的差异，重置了css样式，让浏览器之间可以由一个基本相同的样式基准，并在该基准的基础上进行开发。</p>
<h2 id="引入CSS_Reset样式">引入CSS Reset样式</h2><p>引入CSS Reset，意味着告诉浏览器将所有元素应用上reset的样式，再使用针对页面或业务的特定样式。对于页面加载而言，这不算一个最优的方式，但对于组织css代码而言是一个好方法，因为页面针对不同浏览器都在一个统一的基准上开发。</p>
<p>而通常来说CSS Reset网上有许多现成的（可以去上面的链接里找），但直接引入或者直接复制黏贴不是推荐的做法，这里我直接引用：</p>
<blockquote>
<p>The reset styles given here are intentionally very generic. I don’t particularly recommend that you just use this in its unaltered state in your own projects. It should     be tweaked, edited, extended, and otherwise tuned to match your specific reset baseline. Fill in your preferred colors for the page, links, and so on. In other words, this is a starting point, not a self-contained black box of no-touchiness.</p>
</blockquote>
<p>简单地说，引入bootstrap后，即使html中没有定义任何class或者inline style，依然可以呈现出优雅的页面，即推荐大家根据自己的需求定制自己的CSS Reset，而不是直接拷贝（虽然确实省事）。</p>
<a id="more"></a>
<h2 id="CSS设计">CSS设计</h2><p>在为一个站点写css样式时，我认为可以分为三层：全局层，模块层，页面逻辑层。</p>
<p>全局层代表的是应用在所有页面上样式，模块层值的是应用在各个具有相同样式规则的元素上的，页面逻辑层是每个页面都不共享的一些特殊样式。而CSS Reset则可以作为全局层的一部分让所有页面具有相同的样式基准，对于模块层和页面逻辑层，举个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line">    <span class="comment">/*全局层*/</span></span><br><span class="line">    * <span class="rules">&#123; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0px</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0px</span></span></span>; <span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*模块层*/</span></span><br><span class="line">    <span class="class">.list</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> -<span class="number">10px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> -<span class="number">10px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br><span class="line">    <span class="class">.list</span> <span class="class">.list-item</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">padding-left</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">padding-right</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br><span class="line">    <span class="class">.list</span><span class="pseudo">:after</span>, <span class="class">.clearfix</span><span class="pseudo">:after</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">""</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">display</span>:<span class="value"> table</span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*页面逻辑层*/</span></span><br><span class="line">    <span class="class">.testlist</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#3c3c3c</span></span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list-item testlist"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list-item testlist"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list-item testlist"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list-item testlist"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list-item testlist"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>list模块包括了样式<code>.list</code>、<code>.list-item</code>，可应用于一些需要呈现列表的情景，而<code>testlist</code>样式仅包含应用于特定场景的特殊样式。不难发现，CSS中的注释对代码维护有着重大意义。</p>
<h2 id="关于使用Universal_Selector(*)做CSS_Reset">关于使用Universal Selector(*)做CSS Reset</h2><p>使用全局选择器或者叫通配选择器(*)，是一种最简便的CSS Reset的方式，可能会是这样子的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>或许会在这个基础上再加上其他style的重设，比如<code>border: 0;</code>或者是<code>outline:0;</code>这样子。但这样子维护CSS Reset是有许多弊端的：</p>
<ul>
<li>没有明确的指出哪个元素是被reset的了，这个算是语义上的问题</li>
<li>样式继承将无法作用于任何元素，因为全局选择器会匹配所用的元素，其样式权值为<code>0,0,0,1</code>，而继承样式的权值为<code>&lt;0,0,0,1</code>，这也导致了子元素的样式需要重复的逐个定义（个人认为是主要隐患）</li>
<li>由于该选择器将匹配所有元素，可能会增加页面的加载时间（这个是有争议的观点）</li>
<li>IE6、IE7不支持该选择器</li>
</ul>
<p>由于使用这种reset的方式虽然简便，但可能会带来一些隐患，使用它时需要清楚的知道里面的样式规则是否会带来丢失继承的隐患，其实<code>Tripoli CSS Reset</code>中也是有部分样式是使用这个选择器的，大家根据需求自己权衡。</p>
<h2 id="小提示">小提示</h2><p>在写CSS Reset的时候应该要注意，比如我设置：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#333</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>那么导致的问题是需要每次手动设置a标签的<code>:focus</code>、<code>:hover</code>等样式，因为对a标签应用该样式会覆盖所有a标签的默认样式，包括伪类（伪类也被认为是应用于a标签的样式，伪类样式权值为<code>0,0,1,0</code>）。同样的问题也会出现在像<code>outline</code>这样的样式上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有一个专门讲CSS Reset的站点。 <a href="http://www.cssreset.com/">site</a></p>
<p>由于各大浏览器的user agent样式（即默认样式）不同，为了尽可能避免浏览器之间样式的差异，重置了css样式，让浏览器之间可以由一个基本相同的样式基准，并在该基准的基础上进行开发。</p>
<h2 id="引入CSS_Reset样式">引入CSS Reset样式</h2><p>引入CSS Reset，意味着告诉浏览器将所有元素应用上reset的样式，再使用针对页面或业务的特定样式。对于页面加载而言，这不算一个最优的方式，但对于组织css代码而言是一个好方法，因为页面针对不同浏览器都在一个统一的基准上开发。</p>
<p>而通常来说CSS Reset网上有许多现成的（可以去上面的链接里找），但直接引入或者直接复制黏贴不是推荐的做法，这里我直接引用：</p>
<blockquote>
<p>The reset styles given here are intentionally very generic. I don’t particularly recommend that you just use this in its unaltered state in your own projects. It should     be tweaked, edited, extended, and otherwise tuned to match your specific reset baseline. Fill in your preferred colors for the page, links, and so on. In other words, this is a starting point, not a self-contained black box of no-touchiness.</p>
</blockquote>
<p>简单地说，引入bootstrap后，即使html中没有定义任何class或者inline style，依然可以呈现出优雅的页面，即推荐大家根据自己的需求定制自己的CSS Reset，而不是直接拷贝（虽然确实省事）。</p>]]>
    
    </summary>
    
      <category term="css" scheme="http://leozdgao.github.io/tags/css/"/>
    
      <category term="HTML/CSS" scheme="http://leozdgao.github.io/categories/HTML-CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shebang]]></title>
    <link href="http://leozdgao.github.io/2015/03/01/Shebang/"/>
    <id>http://leozdgao.github.io/2015/03/01/Shebang/</id>
    <published>2015-03-01T03:25:35.000Z</published>
    <updated>2015-03-21T03:27:36.287Z</updated>
    <content type="html"><![CDATA[<p><a href="http://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="external">wiki</a>链接</p>
<p>在计算机科学中，Shebang（也称为Hashbang）是一个由井号和叹号构成的字符序列（<strong>#!</strong>），其出现在文本文件的第一行的前两个字符。 在文件中存在Shebang的情况下，类Unix操作系统的程序载入器会分析Shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有Shebang的文件路径作为该解释器的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span></span><br></pre></td></tr></table></figure>
<p>开头的文件在执行时会实际调用/bin/sh程序（通常是Bourne shell或兼容的shell，例如bash、dash等）来执行。</p>
<h2 id="语法">语法</h2><p>Shebang这一语法特性由<code>#!</code>开头，即井号和叹号。 在开头字符之后，可以有一个或数个空白字符，后接解释器的绝对路径，用于调用解释器。Shebang行也可以包含需要传递到解释器的特定选项。然而，选项传递的方式随实现的不同而不同。</p>
<p>使用<code>#!/usr/bin/env</code>脚本解释器名称是一种常见的在不同平台上都能正确找到解释器的办法。</p>
<p><strong>Node global bin</strong>：<code>#!/usr/bin/env node</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="external">wiki</a>链接</p>
<p>在计算机科学中，Shebang（也称为Hashbang）是一个由井号和叹号构成的字]]>
    </summary>
    
      <category term="linux" scheme="http://leozdgao.github.io/tags/linux/"/>
    
      <category term="操作系统基础" scheme="http://leozdgao.github.io/categories/os/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git Flow简介]]></title>
    <link href="http://leozdgao.github.io/2015/02/28/Git-Flow%E7%AE%80%E4%BB%8B/"/>
    <id>http://leozdgao.github.io/2015/02/28/Git-Flow简介/</id>
    <published>2015-02-28T03:13:19.000Z</published>
    <updated>2015-03-21T03:15:41.637Z</updated>
    <content type="html"><![CDATA[<p>摘抄自：<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">原文</a>，<a href="http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/" target="_blank" rel="external">译文</a></p>
<p><img src="http://7sbm5t.com1.z0.glb.clouddn.com/gitflow_0.png" alt="git flow"></p>
<a id="more"></a>
<h4 id="主要分支">主要分支</h4><ul>
<li>develop：反映了开发过程中最新的提交变更。</li>
<li>master：当develop分支的源码达到一个稳定的状态时，develop上的变更都应该以某种方式合并回master分支，每一个commit对应一个版本，并使用发布版本号打上标签。</li>
</ul>
<h4 id="特性分支">特性分支</h4><p>可能的分支来源：develop<br>必须合并回：develop<br>分支命名约定：任何除master，develop，release-*，或hotfix-*以外的名称</p>
<p>特性分支用来开发下个版本的新特性，最终会被合并回develop分支，往往只存在于开发者的仓库中，而不会出现在origin。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="blockquote">&gt; git checkout develop</span></span><br><span class="line">Switch to branch ‘develop’</span><br><span class="line"><span class="blockquote">&gt; git merge -no-ff myfeature</span></span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="blockquote">&gt; git branch -d myfeature</span></span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line"><span class="blockquote">&gt; git push origin develop</span></span><br></pre></td></tr></table></figure>
<h4 id="发布分支">发布分支</h4><p>可能的分支来源：develop<br>必须合并回：develop和master<br>分支命名约定：release-*</p>
<p>发布分支为准备新的产品版本发布做支持，它允许你在最后时刻检查所有的细节。在分布分支创建的时候，对应的版本发布才获得一个版本号。</p>
<p><strong>创建一个发布分支</strong></p>
<p>发布分支从develop分支创建，develop分支的状态已经是准备好“下一版本”发布了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; git checkout -<span class="tag">b</span> releases-<span class="number">1.2</span> develop</span><br><span class="line">Switched to <span class="tag">a</span> new branch “release-<span class="number">1.2</span>”</span><br><span class="line">&gt; ./bump-version<span class="class">.sh</span> <span class="number">1.2</span></span><br><span class="line">Files modified successfully. version bumped to <span class="number">1.2</span>.</span><br><span class="line">&gt; git commit -<span class="tag">a</span> -m “Bumped version number to <span class="number">1.2</span>”</span><br><span class="line">[release-<span class="number">1.2</span> <span class="number">74</span>d9424] Bumped version number to <span class="number">1.2</span></span><br><span class="line"><span class="number">1</span> files changed. <span class="number">1</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>. <span class="number">1</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>结束一个发布分支</strong></p>
<p>当发布分支达到一个可以正式发布的状态时，将发布分支合并到master，接着master分支上的commit必须被打上标签（tag）。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch ‘master’</span><br><span class="line">&gt; git <span class="built_in">merge</span> –no-ff release-<span class="number">1.2</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br><span class="line">&gt; git tag -<span class="operator">a</span> <span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<p>为了能保留发布分支上的变更，我们还需要将分支合并回develop。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch ‘develop’</span><br><span class="line">&gt; git <span class="built_in">merge</span> –no-ff release-<span class="number">1.2</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br></pre></td></tr></table></figure>
<p>现在工作才算真正完成了，最后一步是删除发布分支。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">&gt;</span> git branch <span class="keyword">-</span>d <span class="keyword">release</span><span class="keyword">-</span><span class="number">1</span><span class="typename">.2</span></span><br><span class="line">Deleted branch <span class="keyword">release</span><span class="keyword">-</span><span class="number">1</span><span class="typename">.2</span> (was ff452fe).</span><br></pre></td></tr></table></figure>
<h4 id="热补丁分支">热补丁分支</h4><p>可能的分支来源：master<br>必须合并回：develop和master<br>分支命名约定：hotfix-*</p>
<p>当产品版本发现未预期的问题时，需要着手处理，这时就需要热补丁分支。</p>
<p><strong>创建一个热补丁分支</strong></p>
<p>热补丁分支从master分支创建。不要忘记在创建热补丁分支后设定一个新的版本号。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; git checkout -<span class="tag">b</span> hotfix-<span class="number">1.2</span>.<span class="number">1</span> master</span><br><span class="line">Switched to <span class="tag">a</span> new branch “hotfix-<span class="number">1.2</span>.<span class="number">1</span>″</span><br><span class="line">&gt; ./bump-version<span class="class">.sh</span> <span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">Files modified successfully, version bumped to <span class="number">1.2</span>.<span class="number">1</span>.</span><br><span class="line">&gt; git commit -<span class="tag">a</span> -m “Bumped version number to <span class="number">1.2</span>.<span class="number">1</span>″</span><br><span class="line">[hotfix-<span class="number">1.2</span>.<span class="number">1</span> <span class="number">41</span>e61bb] Bumped version number to <span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line"><span class="number">1</span> files changed, <span class="number">1</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>, <span class="number">1</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<p>修复bug并提交。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git commit -m “Fixed severe production problem”</span><br><span class="line">[hotfix-<span class="number">1.2</span>.<span class="number">1</span> abbe5d6] Fixed severe production problem</span><br><span class="line"><span class="number">5</span> files changed, <span class="number">32</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>, <span class="number">17</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>结束一个热补丁分支</strong></p>
<p>修复完成后，热补丁分支需要合并回master并打上标签，同时也需要被合并回develop。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch ‘develop’</span><br><span class="line">&gt; git <span class="built_in">merge</span> –no-ff hotfix-<span class="number">1.2</span><span class="number">.1</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br></pre></td></tr></table></figure>
<p><em>注：如果这个时候有发布分支存在，热补丁分支的变更则应该合并至发布分支，而不是develop。</em></p>
<p>最后删除临时的热补丁分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; git branch <span class="operator">-d</span> hotfix-<span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">Deleted branch hotfix-<span class="number">1.2</span>.<span class="number">1</span> (was abbe5d6).</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>摘抄自：<a href="http://nvie.com/posts/a-successful-git-branching-model/">原文</a>，<a href="http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/">译文</a></p>
<p><img src="http://7sbm5t.com1.z0.glb.clouddn.com/gitflow_0.png" alt="git flow"></p>]]>
    
    </summary>
    
      <category term="git" scheme="http://leozdgao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React JSX语法说明]]></title>
    <link href="http://leozdgao.github.io/2015/02/21/React-JSX%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/"/>
    <id>http://leozdgao.github.io/2015/02/21/React-JSX语法说明/</id>
    <published>2015-02-21T03:17:00.000Z</published>
    <updated>2015-03-21T03:19:45.445Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是JSX？">什么是JSX？</h2><p>在用React写组件的时候，通常会用到JSX语法，粗看上去，像是在Javascript代码里直接写起了XML标签，实质上这只是一个<strong>语法糖</strong>，每一个XML标签都会被JSX转换工具转换成纯Javascript代码，当然你想直接使用纯Javascript代码写也是可以的，只是利用JSX，组件的结构和组件之间的关系看上去更加清晰。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var MyComponent = React.createClass(&#123;/*<span class="keyword">...</span>*/&#125;);</span><br><span class="line">var myElement = &lt;MyComponent someProperty=&#123;true&#125; /&gt;;</span><br><span class="line">React.render(myElement, document.body);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>一个XML标签，比如<code>&lt;MyComponent someProperty={true} /&gt;</code>会被JSX转换工具转换成什么呢？</p>
<p>比如：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var Nav = React.createClass(&#123;/*<span class="keyword">...</span>*/&#125;);</span><br><span class="line">var app = &lt;Nav color=<span class="string">"blue"</span>&gt;&lt;Profile&gt;click&lt;/Profile&gt;&lt;/Nav&gt;;</span><br></pre></td></tr></table></figure></p>
<p>会被转化为：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Nav = React.createClass(&#123;/*<span class="keyword">...</span>*/&#125;);</span><br><span class="line">var app = React.createElement(</span><br><span class="line">    Nav,</span><br><span class="line">    &#123;color:<span class="string">"blue"</span>&#125;,</span><br><span class="line">    React.createElement(Profile, null, <span class="string">"click"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>那么也就是说，我们写一个XML标签，实质上就是在调用<code>React.createElement</code>这个方法，并返回一个<code>ReactElement</code>对象。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactElement createElement(</span><br><span class="line">    string/ReactClass type,</span><br><span class="line">    [object props],</span><br><span class="line">    [children <span class="keyword">...</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个方法的第一个参数可以是一个字符串，表示是一个HTML标准内的元素，或者是一个<code>ReactClass</code>类型的对象，表示我们之前封装好的自定义组件。第二个参数是一个对象，或者说是字典也可以，它保存了这个元素的所有固有属性（即传入后基本不会改变的值）。从第三个参数开始，之后的参数都被认作是元素的子元素。</p>
<h2 id="JSX转化器">JSX转化器</h2><p>要把带有JSX语法的代码转化为纯Javascript代码，有多种方式，对于内联与HTML中的代码或者是未经过转化的外部文件，在<code>script</code>标签中要加上<code>type=&quot;text/jsx&quot;</code>，并引入<code>JSXTransformer.js</code>文件即可，不过这种方式并不建议在生产环境使用，建议的方法是在代码上线前就将代码转换好，可以使用<code>npm</code><strong>全局安装</strong><code>react-tools</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g react-tools</span><br></pre></td></tr></table></figure>
<p>并使用命令行工具转化即可（具体用法可以参考<code>jsx -h</code>）：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsx src<span class="regexp">/ build/</span></span><br></pre></td></tr></table></figure>
<p>如果使用自动化工具，比如<code>gulp</code>的话，可以使用相应插件<code>gulp-react</code>。</p>
<h2 id="使用HTML标签">使用HTML标签</h2><p>要创建一个HTML标准中存在的元素，直接像写HTML代码一样即可：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> myDivElement = &lt;div className=<span class="string">"foo"</span> /&gt;;</span><br><span class="line">React.render(myDivElement, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p>不过需要注意的是<code>class</code>和<code>for</code>这两个属性，JSX语法最终是要被转换为纯Javascript的，所以要和在Javascript DOM中一样，用<code>className</code>和<code>htmlFor</code>。</p>
<p>还有一点是，在创建HTML标准内的元素时，JSX转化器会丢弃那些非标准的属性，如果一定要添加自定义属性，那么需要在这些自定义属性之前添加<code>data-</code>前缀。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">div</span> data-custom-attribute=<span class="string">"foo"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="命名空间式组件">命名空间式组件</h2><p>比如开发组件的时候，一个组件有多个子组件，你希望这些子组件可以作为其父组件的属性，那么可以像这样用：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">Form</span> = MyFormComponent;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="keyword">App</span> = (</span><br><span class="line">  &lt;<span class="keyword">Form</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">Form</span>.Row&gt;</span><br><span class="line">      &lt;<span class="keyword">Form</span>.<span class="keyword">Label</span> /&gt;</span><br><span class="line">      &lt;<span class="keyword">Form</span>.<span class="keyword">Input</span> /&gt;</span><br><span class="line">    &lt;/<span class="keyword">Form</span>.Row&gt;</span><br><span class="line">  &lt;/<span class="keyword">Form</span>&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样你只需将子组件的<code>ReactClass</code>作为其父组件的属性：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var MyFormComponent = React.createClass(&#123; <span class="keyword">...</span> &#125;);</span><br><span class="line"> </span><br><span class="line">MyFormComponent.Row = React.createClass(&#123; <span class="keyword">...</span> &#125;);</span><br><span class="line">MyFormComponent.Label = React.createClass(&#123; <span class="keyword">...</span> &#125;);</span><br><span class="line">MyFormComponent.Input = React.createClass(&#123; <span class="keyword">...</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>而创建子元素可以直接交给JSX转化器：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">App</span> = (</span><br><span class="line">    React.createElement(<span class="keyword">Form</span>, null,</span><br><span class="line">        React.createElement(<span class="keyword">Form</span>.Row, null,</span><br><span class="line">            React.createElement(<span class="keyword">Form</span>.<span class="keyword">Label</span>, null),</span><br><span class="line">            React.createElement(<span class="keyword">Form</span>.<span class="keyword">Input</span>, null)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><em>该功能需要0.11及以上版本</em></p>
<h2 id="Javascript表达式">Javascript表达式</h2><p>在JSX语法中写Javascript表达式只需要用<code>{}</code>即可，比如下面这个使用三目运算符的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input (JSX):</span></span><br><span class="line"><span class="keyword">var</span> content = &lt;Container&gt;&#123;<span class="built_in">window</span>.isLoggedIn ? &lt;Nav /&gt; : &lt;Login /&gt;&#125;&lt;/Container&gt;;</span><br><span class="line"><span class="comment">// Output (JS):</span></span><br><span class="line"><span class="keyword">var</span> content = React.createElement(</span><br><span class="line">    Container,</span><br><span class="line">    <span class="keyword">null</span>,</span><br><span class="line">    <span class="built_in">window</span>.isLoggedIn ? React.createElement(Nav) : React.createElement(Login)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>不过要注意的是，JSX语法只是语法糖，它的背后是调用<code>ReactElement</code>的构造方法<code>React.createElement</code>的，所以类似这样的写法是不可以的：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This JSX:</span></span><br><span class="line">&lt;<span class="keyword">div</span> id=&#123;<span class="keyword">if</span> (condition) &#123; <span class="string">'msg'</span> &#125;&#125;&gt;Hello World!&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Is transformed to this JS:</span></span><br><span class="line">React.createElement(<span class="string">"div"</span>, &#123;id: <span class="keyword">if</span> (condition) &#123; <span class="string">'msg'</span> &#125;&#125;, <span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure>
<p>可以从转化后的Javascript代码中看出明显的语法错误，所以要不用三目运算符，要不就这样写：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &lt;<span class="keyword">div</span> <span class="property">id</span>='msg'&gt;Hello World!&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"><span class="keyword">else</span> &lt;<span class="keyword">div</span>&gt;Hello World!&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="传播属性（Spread_Attributes）">传播属性（Spread Attributes）</h2><p>在JSX中，可以使用<code>...</code>运算符，表示将一个对象的键值对与<code>ReactElement</code>的<code>props</code>属性合并，这个<code>...</code>运算符的实现类似于ES6 Array中的<code>...</code>运算符的特性。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> props <span class="subst">=</span> &#123; foo: x, bar: y &#125;;</span><br><span class="line"><span class="built_in">var</span> component <span class="subst">=</span> <span class="subst">&lt;</span>Component &#123; <span class="attribute">...</span>props &#125; <span class="subst">/</span><span class="subst">&gt;</span>;</span><br></pre></td></tr></table></figure>
<p>这样就相当于：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var component = <span class="tag">&lt;<span class="title">Component</span> <span class="attribute">foo</span>=<span class="value">&#123;x&#125;</span> <span class="attribute">bar</span>=<span class="value">&#123;y&#125;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>它也可以和普通的XML属性混合使用，需要同名属性，后者将覆盖前者：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> props <span class="subst">=</span> &#123; foo: <span class="string">'default'</span> &#125;;</span><br><span class="line"><span class="built_in">var</span> component <span class="subst">=</span> <span class="subst">&lt;</span>Component &#123;<span class="attribute">...</span>props&#125; foo<span class="subst">=</span>&#123;<span class="string">'override'</span>&#125; <span class="subst">/</span><span class="subst">&gt;</span>;</span><br><span class="line">console<span class="built_in">.</span><span class="keyword">log</span>(component<span class="built_in">.</span>props<span class="built_in">.</span>foo); <span class="comment">// 'override'</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料（可能无法直接打开链接）">参考资料（可能无法直接打开链接）</h2><ul>
<li><a href="http://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX in Depth</a></li>
<li><a href="http://facebook.github.io/react/docs/jsx-spread.html" target="_blank" rel="external">JSX Spread Attributes</a></li>
<li><a href="http://facebook.github.io/react/tips/if-else-in-JSX.html" target="_blank" rel="external">If-Else in JSX</a></li>
<li><a href="http://facebook.github.io/react/docs/jsx-gotchas.html" target="_blank" rel="external">JSX Gotchas</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是JSX？">什么是JSX？</h2><p>在用React写组件的时候，通常会用到JSX语法，粗看上去，像是在Javascript代码里直接写起了XML标签，实质上这只是一个<strong>语法糖</strong>，每一个XML标签都会被JSX转换工具转换成纯Javascript代码，当然你想直接使用纯Javascript代码写也是可以的，只是利用JSX，组件的结构和组件之间的关系看上去更加清晰。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var MyComponent = React.createClass(&#123;/*<span class="keyword">...</span>*/&#125;);</span><br><span class="line">var myElement = &lt;MyComponent someProperty=&#123;true&#125; /&gt;;</span><br><span class="line">React.render(myElement, document.body);</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="react.js" scheme="http://leozdgao.github.io/tags/react-js/"/>
    
      <category term="JS类库探索" scheme="http://leozdgao.github.io/categories/jslibs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用React创建评论区（Comment Box）组件]]></title>
    <link href="http://leozdgao.github.io/2015/02/19/%E5%88%A9%E7%94%A8React%E5%88%9B%E5%BB%BA%E8%AF%84%E8%AE%BA%E5%8C%BA%EF%BC%88Comment-Box%EF%BC%89%E7%BB%84%E4%BB%B6/"/>
    <id>http://leozdgao.github.io/2015/02/19/利用React创建评论区（Comment-Box）组件/</id>
    <published>2015-02-19T03:20:49.000Z</published>
    <updated>2015-03-21T03:22:57.169Z</updated>
    <content type="html"><![CDATA[<p>本文是在阅读学习了官方的<a href="http://facebook.github.io/react/docs/tutorial.html" target="_blank" rel="external">React Tutorial</a>之后的整理，实例<a href="http://7sbm5t.com1.z0.glb.clouddn.com/react0_ex.html" target="_blank" rel="external">链接</a>。</p>
<h2 id="开始使用React">开始使用React</h2><p>首先从官方获取React.js的最新版本（<a href="http://facebook.github.io/react/downloads.html" target="_blank" rel="external">v0.12.2</a>），或者下载官方的<a href="http://facebook.github.io/react/downloads/react-0.12.2.zip" target="_blank" rel="external">Starter Kit</a>，并在我们的html中引入它们：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>React Test Page<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../build/react.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../build/JSXTransformer.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="JSX语法">JSX语法</h2><p>我们可以在React组件的代码中发现xml标签似乎直接写进了javascript里：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React.render(</span><br><span class="line">    &lt;CommentBox /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这种写法被称作JSX，是React的一个可选功能，将xml标签直接写在javascript中看上去比调用javascript方法要更加直观些。要正常使用这个功能，需要在你的页面中引入<code>JSXTransformer.js</code>文件，或者使用<code>npm</code>安装<code>react-tools</code>，将包含JSX语法的源文件编译成常规的javascript文件，比较推荐的是后者，因为使用后者让页面可以直接使用编译后的javascript文件而不需要在加载页面时进行JSX编译。</p>
<p>JSX中的类HTML标签并不是真正的HTML元素，也不是一段HTML字符串，而是实例化了的React组件，关于JSX语法的更多内容，可以看这篇文章。</p>
<a id="more"></a>
<h2 id="创建组件">创建组件</h2><p>React可以为我们创建模块化、可组合的组件，对于我们需要做的评论区，我们的组件结构如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> <span class="constant">CommentBox</span></span><br><span class="line"></span>    -<span class="ruby"> <span class="constant">CommentList</span></span><br><span class="line"></span>        -<span class="ruby"><span class="constant">Comment</span></span><br><span class="line"></span>    -<span class="ruby"> <span class="constant">CommentForm</span></span></span><br></pre></td></tr></table></figure></p>
<p>通过<code>React.createClass()</code>可以一个React元素，我们可以像这样定义我们的CommentBox，并通过<code>React.render()</code>方法可以让我们在指定的容器中将React元素渲染为一个DOM组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"content"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/jsx"</span>&gt;</span><span class="javascript"></span><br><span class="line">        <span class="keyword">var</span> CommentBox = React.createClass(&#123;</span><br><span class="line">            render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"contentBox"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Comments<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">CommentList</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">CommentForm</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        React.render(</span><br><span class="line">            <span class="tag">&lt;<span class="title">CommentBox</span> /&gt;</span>,</span><br><span class="line">            document.getElementById('content')</span><br><span class="line">        );</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从这个例子也可以看出一个组件可以包含子组件，组件之间是可以组合的（Composing），并呈现一个树形结构，也可以说render方法中的的CommentBox代表的是组件树的根元素。那么接下来我们来创建CommentList和CommentForm这两个子组件。</p>
<p>首先是CommentList组件，这个组件是用来呈现评论列表的，根据开始我们设计的组件结构树，这个组件应该是包含许多Comment子组件的，那么，假设我们已经获取到评论数据了：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var comments = [</span><br><span class="line">    &#123;<span class="string">author:</span> <span class="string">"Pete Hunt"</span>, <span class="string">text:</span> <span class="string">"This is one comment"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">author:</span> <span class="string">"Jordan Walke"</span>, <span class="string">text:</span> <span class="string">"This is *another* comment"</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>我们需要把数据传递给CommentList组件才能让它去呈现，那么如何传递呢？我们可以通过<code>this.props</code>来访问组件标签上的属性，比如我们在CommentBox组件的代码中做如下修改：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">CommentList</span> <span class="attribute">data</span>=<span class="value">comments</span>  /&gt;</span></span><br></pre></td></tr></table></figure>
<p>于是在CommentList组件中，我们可以通过访问<code>this.props.data</code>来获取到我们的评论数据。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> commentNodes = <span class="keyword">this</span>.props.data.map(<span class="function"><span class="keyword">function</span><span class="params">(comment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;Comment author=&#123;comment.author&#125;&gt;</span><br><span class="line">                    &#123;comment.text&#125;</span><br><span class="line">                &lt;/Comment&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"commentList"</span>&gt;</span><br><span class="line">                &#123;commentNodes&#125;       </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接下来写Comment组件，这个组件用于呈现单个评论，我们希望它可以支持markdown语法，于是我们引入<a href="https://github.com/showdownjs/showdown" target="_blank" rel="external">showdown</a>这个库，在HTML中引入它之后，我们可以调用它让我们的评论支持Markdown语法。在这里我们需要<code>this.props.children</code>这个属性，它返回了该组件标签里的所有子元素。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> converter = <span class="keyword">new</span> Showdown.converter();</span><br><span class="line"><span class="keyword">var</span> Comment = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"comment"</span>&gt;</span><br><span class="line">                &lt;h2 className=<span class="string">"commentAuthor"</span>&gt;</span><br><span class="line">                    &#123;<span class="keyword">this</span>.props.author&#125;</span><br><span class="line">                &lt;/h2&gt;</span><br><span class="line">                &#123;converter.makeHtml(<span class="keyword">this</span>.props.children.toString())&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们看一下现在的效果：<br><img src="http://7sbm5t.com1.z0.glb.clouddn.com/react0_pic0.png" alt="效果"></p>
<p>我们发现经过解析后html标签被直接呈现了上去，因为React默认是有XSS保护的，所有对呈现的内容进行了转义，但在现在的场景中，我们并不需要它的转义（如果取消React默认的XSS保护，那么就需要仰仗于我们引入的库具有XSS保护或者我们手动处理），这时我们可以这样：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> converter = <span class="keyword">new</span> Showdown.converter();</span><br><span class="line"><span class="keyword">var</span> Comment = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 通过this.props.children访问元素的子元素</span></span><br><span class="line">        <span class="keyword">var</span> rawHtml = converter.makeHtml(<span class="keyword">this</span>.props.children.toString());</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">// 通过this.props访问元素的属性</span></span><br><span class="line">            <span class="comment">// 不转义，直接插入纯HTML</span></span><br><span class="line">            &lt;div className=<span class="string">"comment"</span>&gt;</span><br><span class="line">                &lt;h2 className=<span class="string">"commentAuthor"</span>&gt;&#123;<span class="keyword">this</span>.props.author&#125;&lt;/h2&gt;</span><br><span class="line">                &lt;span dangerouslySetInnerHTML=&#123;&#123;__html: rawHtml&#125;&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>好了，接下来我们的CommentList算是完成了，我们需要加上CommentForm组件让我们可以提交评论：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">CommentForm</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">    handleSubmit: function(e) &#123;</span><br><span class="line"> </span><br><span class="line">        e.preventDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> author = this.refs.author.getDOMNode().value.trim();</span><br><span class="line">        <span class="keyword">var</span> text = this.refs.text.getDOMNode().value.trim();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!text || !author) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        // <span class="type">TODO</span> 修改commentList</span><br><span class="line"> </span><br><span class="line">        // 获取原生<span class="type">DOM</span>元素</span><br><span class="line">        this.refs.author.getDOMNode().value = '';</span><br><span class="line">        this.refs.text.getDOMNode().value = '';</span><br><span class="line">    &#125;,</span><br><span class="line">    render: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            // 为元素添加submit事件处理程序</span><br><span class="line">            // 用<span class="keyword">ref</span>为子组件命名，并可以在this.refs中引用</span><br><span class="line">            &lt;form className=<span class="string">"commentForm"</span> onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">                &lt;input <span class="keyword">type</span>=<span class="string">"text"</span> placeholder=<span class="string">"Your name"</span> <span class="keyword">ref</span>=<span class="string">"author"</span>/&gt;</span><br><span class="line">                &lt;input <span class="keyword">type</span>=<span class="string">"text"</span> placeholder=<span class="string">"Say something..."</span> <span class="keyword">ref</span>=<span class="string">"text"</span>/&gt;</span><br><span class="line">                &lt;input <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"Post"</span>/&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从以上的代码中我们可以发现，我们可以为我们的组件添加事件处理程序，比如在这里我们需要利用form的submit事件，于是直接在标签上添加<code>onSubmit</code>的属性即可。需要注意的是，事件属性需要满足驼峰命名规则，也就是说如果是要添加click事件，那就要添加<code>onClick</code>，以此类推。还有一点就是我们需要获取两个文本框中的内容，这里使用的方法是在<code>input</code>标签上添加<code>ref</code>属性，这样就可以认为这个<code>input</code>是它的一个子组件，然后就可以通过访问<code>this.refs</code>来访问到这个子组件了，通过调用<code>getDOMNode</code>方法可以获取原生的DOM对象进行相应的操作。</p>
<p>我们发现到现在为止，我们的页面是静态的，但我们希望可以在成功提交了评论后可以立刻在评论列表中看到自己的评论，并可以每隔一段时间获取最新的评论，也就是说我们希望我们的CommentBox可以动态地改变状态。</p>
<p>首先我们先让CommentBox组件可以通过AJAX请求（在这里我用setTimeout来模拟获取数据的延迟），从服务器端获取评论数据同时更新CommentList。React组件有一个私有的<code>this.state</code>属性用于保存组件可变状态的数据，但一开始我们需要的是一个初始的状态，初始状态可以通过设置组件的<code>getInitialState</code>方法，它的返回值即为状态初始值。这个时候我们不是从标签的属性上直接获取数据了，需要通过访问<code>this.state</code>来获取（这个<code>state</code>属性如果直接用javascript访问会返回<code>undefined</code>，但可以在JSX中可以像<code>this.state.data</code>这样使用）：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;data: []&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"commentBox"</span>&gt;</span><br><span class="line">        &lt;h1&gt;Comments&lt;/h1&gt;</span><br><span class="line">        &lt;CommentList data=&#123;<span class="keyword">this</span>.state.data&#125; /&gt;</span><br><span class="line">        &lt;CommentForm /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接下来我们需要获取评论数据，我们可以在组件的<code>componentDidMount</code>方法中实现，这个方法会在组件呈现在页面上之后会被立刻调用一次，我们就在这个方法中获取到数据后更新下组件的状态，要更新组件的状态需要调用组件的<code>this.setState</code>方法，于是我们就这样写：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</span><br><span class="line">    <span class="comment">// 在组件的生命周期中仅执行一次，用于设置初始状态</span></span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;data: []&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    loadCommentsFromServer : <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 动态更新state</span></span><br><span class="line">            self.setState(&#123;data: comments&#125;);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当组件render完成后自动被调用</span></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.loadCommentsFromServer();</span><br><span class="line">        setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"commentBox"</span>&gt;</span><br><span class="line">                &lt;h1&gt;Comments&lt;/h1&gt;</span><br><span class="line">                &lt;CommentList data=&#123;<span class="keyword">this</span>.state.data&#125; /&gt;</span><br><span class="line">                &lt;CommentForm /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在我们已经可以更新评论列表里的数据了，那么同样的我们在CommentForm中成功提交的评论也要可以在CommentList中呈现出来，在这里需要注意的是我们现在设置的初始状态是CommentBox这个组件的，修改状态也是修改的CommentBox的状态，那么如果要在CommentForm中改变CommentBox的状态，就需要在CommentBox组件中通过标签属性的方式传递一个方法给子组件CommentForm，让CommentForm组件中的<code>handleSubmit</code>可以调用这个方法（也就是上面TODO的位置），于是我们的代码就是这样的：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</span><br><span class="line">    <span class="comment">// 在组件的生命周期中仅执行一次，用于设置初始状态</span></span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;data: []&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    onCommentSubmit: <span class="function"><span class="keyword">function</span><span class="params">(comment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟提交数据</span></span><br><span class="line">        comments.push(comment);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 动态更新state</span></span><br><span class="line">            self.setState(&#123;data: comments&#125;);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    loadCommentsFromServer : <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 动态更新state</span></span><br><span class="line">            self.setState(&#123;data: data&#125;);</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当组件render完成后自动被调用</span></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.loadCommentsFromServer();</span><br><span class="line">        setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">// 并非是真正的DOM元素，是React的div组件，默认具有XSS保护</span></span><br><span class="line">            &lt;div className=<span class="string">"commentBox"</span>&gt;</span><br><span class="line">                &lt;h1&gt;Comments&lt;/h1&gt;</span><br><span class="line">                &lt;CommentList data=&#123;<span class="keyword">this</span>.state.data&#125; /&gt;</span><br><span class="line">                &lt;CommentForm onCommentSubmit=&#123;<span class="keyword">this</span>.onCommentSubmit&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> CommentForm = React.createClass(&#123;</span><br><span class="line">    handleSubmit: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="comment">// e.returnValue = false;</span></span><br><span class="line">        <span class="keyword">var</span> author = <span class="keyword">this</span>.refs.author.getDOMNode().value.trim();</span><br><span class="line">        <span class="keyword">var</span> text = <span class="keyword">this</span>.refs.text.getDOMNode().value.trim();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!text || !author) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.props.onCommentSubmit(&#123;author: author, text: text&#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取原生DOM元素</span></span><br><span class="line">        <span class="keyword">this</span>.refs.author.getDOMNode().value = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">this</span>.refs.text.getDOMNode().value = <span class="string">''</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">// 为元素添加submit事件处理程序</span></span><br><span class="line">            <span class="comment">// 用ref为子组件命名，并可以在this.refs中引用</span></span><br><span class="line">            &lt;form className=<span class="string">"commentForm"</span> onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"Your name"</span> ref=<span class="string">"author"</span>/&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"Say something..."</span> ref=<span class="string">"text"</span>/&gt;</span><br><span class="line">                &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Post"</span>/&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>到此为止，我们的CommentBox组件就大功告成了，实例<a href="http://7sbm5t.com1.z0.glb.clouddn.com/react0_ex.html" target="_blank" rel="external">链接</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文是在阅读学习了官方的<a href="http://facebook.github.io/react/docs/tutorial.html">React Tutorial</a>之后的整理，实例<a href="http://7sbm5t.com1.z0.glb.clouddn.com/react0_ex.html">链接</a>。</p>
<h2 id="开始使用React">开始使用React</h2><p>首先从官方获取React.js的最新版本（<a href="http://facebook.github.io/react/downloads.html">v0.12.2</a>），或者下载官方的<a href="http://facebook.github.io/react/downloads/react-0.12.2.zip">Starter Kit</a>，并在我们的html中引入它们：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>React Test Page<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../build/react.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../build/JSXTransformer.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="JSX语法">JSX语法</h2><p>我们可以在React组件的代码中发现xml标签似乎直接写进了javascript里：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React.render(</span><br><span class="line">    &lt;CommentBox /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这种写法被称作JSX，是React的一个可选功能，将xml标签直接写在javascript中看上去比调用javascript方法要更加直观些。要正常使用这个功能，需要在你的页面中引入<code>JSXTransformer.js</code>文件，或者使用<code>npm</code>安装<code>react-tools</code>，将包含JSX语法的源文件编译成常规的javascript文件，比较推荐的是后者，因为使用后者让页面可以直接使用编译后的javascript文件而不需要在加载页面时进行JSX编译。</p>
<p>JSX中的类HTML标签并不是真正的HTML元素，也不是一段HTML字符串，而是实例化了的React组件，关于JSX语法的更多内容，可以看这篇文章。</p>]]>
    
    </summary>
    
      <category term="react.js" scheme="http://leozdgao.github.io/tags/react-js/"/>
    
      <category term="JS类库探索" scheme="http://leozdgao.github.io/categories/jslibs/"/>
    
  </entry>
  
</feed>