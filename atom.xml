<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Leo.Gao]]></title>
  <subtitle><![CDATA[不积跬步无以至千里]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://leozdgao.github.io/"/>
  <updated>2015-03-23T14:24:21.836Z</updated>
  <id>http://leozdgao.github.io/</id>
  
  <author>
    <name><![CDATA[Leo Gao]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ECMAScript 6新增功能——块级作用域与解构赋值]]></title>
    <link href="http://leozdgao.github.io/2015/03/23/ECMAScript-6%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://leozdgao.github.io/2015/03/23/ECMAScript-6新增功能——块级作用域与解构赋值/</id>
    <published>2015-03-23T14:15:44.000Z</published>
    <updated>2015-03-23T14:24:21.836Z</updated>
    <content type="html"><![CDATA[<p>根据<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门</a>学习了ES6的一些新特性，在io.js v1.61版本进行代码测试，部分代码需要打开了<code>--harmony</code>，<code>--use_strict</code>等flag。</p>
<p>这个系列将将会有如下内容</p>
<ul>
<li>let , const以及块级作用域</li>
<li>变量的解构赋值</li>
<li>新增的方法</li>
<li>Set和Map数据结构</li>
<li>Generator函数</li>
<li>Promise对象</li>
<li>Class和Module</li>
</ul>
<a id="more"></a>
<h2 id="let_,_const以及块级作用域">let , const以及块级作用域</h2><p><em>注：以下代码需要io.js —harmony —use_strict</em></p>
<p>使用let声明的变量仅在所处的代码块中有效，即该变量处于块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>用let声明的变量不存在变量提升，也不允许在代码块中出现相同的声明，即使在let声明之前。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// ReferenceError 'a' is not defined.</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">6</span>;  <span class="comment">// Identifier 'a' is already defined.</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用let声明的变量将绑定其块级作用域，（这边不是特别清晰）可以避免在循环中声明函数时出现的隐患：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);  <span class="comment">// 输出为0-9</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果上面的例子中改为var声明，则会输出10个10。</p>
<p>const拥有和let同样的特点，并且它用于声明常量，尝试改变常量的值不会导致异常，只会默默失败。<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const <span class="literal">a</span> = <span class="number">6</span><span class="comment">;</span></span><br><span class="line"><span class="literal">a</span> = <span class="number">3</span><span class="comment">;</span></span><br><span class="line">console.log(<span class="literal">a</span>)<span class="comment">;  // 6</span></span><br></pre></td></tr></table></figure></p>
<p>用const声明的对象仅是让其对象的引用地址保持不变，无法保证其属性不发生改变，要让对象不被改变，可以在使用const声明的同时，调用方法<code>Object.freeze</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>.freeze(&#123; msg: <span class="string">"Hello world!"</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>在ES6中，函数声明时的作用域在其所处的块级作用域内。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  f();  <span class="comment">// ES5中，由于函数声明提升，输出为'I am inside!'，但在ES6中，结果为'I am outside!'</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>最后，在ES6中规定，在全局使用var或是function声明的变量都会作为全局对象的属性，但用let , const或是class声明的变量，将不会成为全局对象的属性。（这边补充下，在node.js/io.js环境下，一个模块中全局声明的变量是不会成为全局对象global的属性的，要成为其属性，需要显式地赋值）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);  <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">consoel.log(<span class="built_in">window</span>.b);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<h2 id="变量的解构赋值（Destructure）">变量的解构赋值（Destructure）</h2><p><em>注：当前版本的io.js不支持destructure</em></p>
<p>有两种解构赋值方式：数组解构和对象结构<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo, bar] = [<span class="number">1</span>, <span class="number">3</span>];  <span class="comment">// foo = 1, bar = 3</span></span><br><span class="line"><span class="keyword">var</span> [foo, [bar]] = [<span class="number">1</span>, [<span class="number">3</span>]];  <span class="comment">// foo = 1, bar = 3</span></span><br><span class="line"><span class="keyword">var</span> [,,third] = [<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"baz"</span>];  <span class="comment">// third = "baz"</span></span><br><span class="line"><span class="keyword">var</span> [head, ...tail] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; <span class="comment">// head = 1, tail = [2, 3, 4] (array spread特性)</span></span><br><span class="line"><span class="keyword">var</span> [a,b] = [<span class="number">1</span>]; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure></p>
<p>简单地说就是等号两边的模式匹配，如果匹配不成功，则变量值为<code>undefined</code>。对于数组解构，要求的是结构和顺序的匹配，而对于对象解构，要求的是结构和属性名的匹配：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> &#123;foo, bar&#125; = &#123; <span class="attribute">foo</span>: <span class="string">'aaa'</span>, <span class="attribute">bzz</span>: <span class="string">'zzz'</span> &#125; <span class="regexp">//</span> foo = <span class="string">'aaa'</span>, bzz = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p>
<p>如果变量名和属性名不一样也需要解构赋值，可以这样写：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; <span class="string">foo:</span> baz &#125; = &#123; <span class="string">foo:</span> <span class="string">'aaa'</span> &#125;;  <span class="comment">// baz = 'aaa'</span></span><br></pre></td></tr></table></figure></p>
<p>两种解构赋值的方式都可以使用默认值：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [a, <span class="variable">b=</span><span class="number">3</span>] = [<span class="number">6</span>];  // <span class="variable">a =</span> <span class="number">6</span>, <span class="variable">b =</span> <span class="number">3</span></span><br><span class="line">var &#123;foo,<span class="variable">bar=</span><span class="string">"dog"</span>&#125; = &#123;&#125;;  // <span class="variable">foo =</span> undefined, <span class="variable">bar =</span> <span class="string">"dog"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>用途：</strong>（这部分照抄了原文，觉得很有道理，不过鉴于io.js暂时不支持该特性，并未实践过如下用途）</p>
<ol>
<li><p>交换变量的值</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">x</span>, y] = <span class="list">[<span class="keyword">y</span>, x]</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回多个值</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a, b, c] = example();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>
<ol>
<li><p>函数参数的定义及设置默认值（合并了原文中的3和4）</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="keyword">function</span> (url, &#123;</span><br><span class="line">    async = true,</span><br><span class="line">    beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span><br><span class="line">    cache = true,</span><br><span class="line">    complete = <span class="keyword">function</span> () &#123;&#125;,</span><br><span class="line">    crossDomain = false,</span><br><span class="line">    global = true</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        // <span class="keyword">...</span> do stuff</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历Map结构</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (let [<span class="variable">key</span>, value] of <span class="built_in">map</span>) &#123;</span><br><span class="line">   console.<span class="built_in">log</span>(<span class="variable">key</span> + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>一些技巧<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取键名</span><br><span class="line"><span class="keyword">for</span> (let [key] of map) &#123;</span><br><span class="line">  // <span class="keyword">...</span></span><br><span class="line">&#125; </span><br><span class="line">// 获取键值</span><br><span class="line"><span class="keyword">for</span> (let [,value] of map) &#123;</span><br><span class="line">  // <span class="keyword">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>根据<a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a>学习了ES6的一些新特性，在io.js v1.61版本进行代码测试，部分代码需要打开了<code>--harmony</code>，<code>--use_strict</code>等flag。</p>
<p>这个系列将将会有如下内容</p>
<ul>
<li>let , const以及块级作用域</li>
<li>变量的解构赋值</li>
<li>新增的方法</li>
<li>Set和Map数据结构</li>
<li>Generator函数</li>
<li>Promise对象</li>
<li>Class和Module</li>
</ul>]]>
    
    </summary>
    
      <category term="ES6" scheme="http://leozdgao.github.io/tags/ES6/"/>
    
      <category term="javascript" scheme="http://leozdgao.github.io/tags/javascript/"/>
    
      <category term="Javascript基础" scheme="http://leozdgao.github.io/categories/jsbasic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript语言精粹笔记整理]]></title>
    <link href="http://leozdgao.github.io/2015/03/21/Javascript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://leozdgao.github.io/2015/03/21/Javascript语言精粹笔记整理/</id>
    <published>2015-03-21T11:36:13.000Z</published>
    <updated>2015-03-24T12:34:32.510Z</updated>
    <content type="html"><![CDATA[<p>这两天读了一下《Javascript语言精粹》一书，没有想象中的惊艳，不过在薄薄的100多页中浓缩了许多Javascript的编程技巧，值得细细品味。于是做了该笔记，算是对Javascript知识体系的一个回顾和整理，但并没有把书中的代码直接copy&amp;paste，而是对技巧的罗列，其中对继承那部分，有一些自己的理解。</p>
<a id="more"></a>
<h2 id="一些零星的技巧和知识点">一些零星的技巧和知识点</h2><p>Javascript的简单数据类型（原始类型 Primitive）包括Number、String、Boolean、null、undefined，其他所有值都是对象。</p>
<p>在Javascript内部，string以UTF-16存储，每个字符固定2个字节。</p>
<p>当一个Number以0开头时，会试着将其解释为八进制数，如果这个Number包含小数点，则会报出语法错误。</p>
<p>js中的假值（falsy）：false,0,null,undefined,’’,NaN</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">012</span> <span class="comment">// 10</span></span><br><span class="line"><span class="number">089</span> <span class="comment">// 89</span></span><br><span class="line"><span class="number">012.345</span> <span class="comment">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure>
<p><code>ParseInt</code>方法会试着解析一个整形数字</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="number">012</span>)</span></span> <span class="comment">// 10</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="number">012</span>, <span class="number">10</span>)</span></span> <span class="comment">// 10</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="number">012</span>, <span class="number">8</span>)</span></span> <span class="comment">// 8</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">"123Test"</span>)</span></span> <span class="comment">// 123</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(&#123;&#125;)</span></span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>将数字以0开头并试着将它认为是8进制数不是个好的做法，ES6中有八进制数字面量表示法：<code>0o12</code></p>
<p>下面是NaN表现出的一些奇怪行为，要检测NaN应该使用方法<code>isNaN()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">'number'</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> !== <span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"Hello"</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>for...in</code>会遍历到原型链中的元素，如果要避免遍历到原型链中的元素，可以在循环中使用<code>object.hasOwnProperty(variable)</code>来判断其是否属于原型链。</p>
<p><code>typeof</code>运算符结果的可能值有’number’、’string’、’boolean’、’undefined’、’function’和’object’。在用typeof判断数组或<code>null</code>时，将返回’object’。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.apply(arr) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNull</span><span class="params">(obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> obj === <span class="literal">null</span>; <span class="comment">// 注意要三个等号，因为undefined == null返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>||</code>与<code>&amp;&amp;</code>的妙用：</p>
<ul>
<li>对于<code>||</code>，如果第一个表达式为false，则返回第二个表达式的值，否则返回第一个表达式的值。</li>
<li>对于<code>&amp;&amp;</code>，如果第一个表达式为true，则返回第二个表达式的值，否则返回第一个表达式的值。</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = a || <span class="string">"default"</span>; <span class="comment">// 广泛被用于设置默认值</span></span><br><span class="line"><span class="keyword">var</span> b = obj &amp;&amp; obj.<span class="keyword">pro</span>; <span class="comment">// 保证访问属性时因对象为falsy指而报错</span></span><br></pre></td></tr></table></figure>
<h2 id="函数相关">函数相关</h2><p>Javascript没有块级作用域，只有函数级作用域。</p>
<p><strong>闭包</strong>：通过函数字面量创建的函数对象包含一个连到外部上下文的连接，即该函数可以访问它被创建时所处的上下文环境。</p>
<p><strong>模块</strong>：一个提供接口却隐藏状态与实现的函数或对象。</p>
<p>函数在Javascript中有4种调用模式：</p>
<p><strong>方法调用模式</strong><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject.<span class="keyword">method</span>(args); // 此时函数绑定上下文为myobject对象</span><br></pre></td></tr></table></figure></p>
<p><strong>函数调用模式</strong><br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> sum = add(<span class="number">3</span>, <span class="number">4</span>); <span class="regexp">//</span> 此时函数绑定上下文为<span class="built_in">global</span>对象(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>构造器调用模式</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(); <span class="comment">// 如果构造器函数返回值不是一个对象，则返回this</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>new</code>运算符将创建一个继承于Animal原型的对象，并在调用Animal时将该对象绑定给this。</p>
<p><strong>apply调用模式</strong><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.<span class="keyword">toString</span>.apply(obj, <span class="keyword">args</span>);</span><br></pre></td></tr></table></figure></p>
<p>一个普通的函数声明，其上下文绑定为global对象（window），在对象字面量中声明的函数，其上下文绑定为该对象。</p>
<h2 id="原型和继承相关">原型和继承相关</h2><p>原型连接尽在检索值时才会被用到，当该对象没有相应的属性值时，会试着从原型中获取。对象属性的改变不会涉及到原型对象。</p>
<p><code>delete</code>运算符不会触及原型链中的任何对象。</p>
<p><strong>伪类继承</strong>：给Function.prototype赋一个对象，可以把这个对象看作是’基类’<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"animal"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Miao"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.sayHi();</span><br></pre></td></tr></table></figure></p>
<p>这种继承方式还是挺常见的，不过给prototype赋的对象是有讲究的，如果是new一个对象，则会执行构造器，也就是说上例中我们创建的Cat对象可以从原型链上检索到name这个属性。这里我们来对比一下node.js中的util模块里的inherits方法的实现吧：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exports.inherits = <span class="function"><span class="keyword">function</span><span class="params">(ctor, superCtor)</span> </span>&#123;</span><br><span class="line">  ctor.super_ = superCtor;</span><br><span class="line">  ctor.prototype = <span class="built_in">Object</span>.create(superCtor.prototype, &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>: </span>&#123;</span><br><span class="line">      value: ctor,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在node.js的实现中，ctor.prototype的值是以superCtor的原型为原型创建的一个新对象，和上面一种的区别就在于没有执行构造器方法，也就是说如果使用这种方式的继承，Cat对象是无法从原型链上检索到name属性，只能检索到从原型链上继承来的方法。</p>
<p><strong>函数化模式</strong>：该模式并没有像伪类继承那样模仿类继承的概念，而是直接舍弃了new操作符，通过普通函数调用的方式实现继承。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Animal() &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">that</span> = &#123;&#125;;</span><br><span class="line">    <span class="literal">that</span>.name = <span class="string">"animal"</span>;</span><br><span class="line">    <span class="literal">that</span>.sayHi = <span class="keyword">function</span>() &#123; <span class="built_in">console</span>.log(Hi); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">that</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Cat(name) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">that</span> = Animal();</span><br><span class="line">    <span class="literal">that</span>.name = name || <span class="string">"Cat"</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">that</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = Cat(<span class="string">"kitty"</span>);</span><br></pre></td></tr></table></figure>
<p>这种方法不需要使用new操作符，也不涉及到原型，还可以通过各种闭包来保存私有的状态。</p>
<p>我个人还是会更倾向于写伪类继承的模式，可能是后端出身的关系，觉得其更符合我的思维方式。不过函数化模式更多是用于保存私用的状态，主要不太会用它实现继承。</p>
<p>看到过如下的一种做法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SkyScroll = <span class="function"><span class="keyword">function</span><span class="params">(opts)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SkyScroll.prototype.init(opts); &#125;</span><br><span class="line">SkyScroll.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span><span class="params">(opts)</span> </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// other methods</span></span><br><span class="line">&#125;;</span><br><span class="line">SkyScroll.prototype.init.prototype = SkyScroll.prototype;</span><br><span class="line"><span class="built_in">window</span>.SkyScroll = SkyScroll;</span><br></pre></td></tr></table></figure>
<p>这种方法说不上和继承有关系，不过有一定特点，就是不论你使用<code>var a = SkyScroll({})</code>还是用new操作符调用构造器<code>var b = new SkyScroll({})</code>返回的结果都是相同的，不会因为使用函数调用模式调用构造器而污染全局环境，使用构造器模式调用返回的为一个对象，这个对象可以被正常返回，所以这两种方式都可以成功构造一个SkyScroll对象。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天读了一下《Javascript语言精粹》一书，没有想象中的惊艳，不过在薄薄的100多页中浓缩了许多Javascript的编程技巧，值得细细品味。于是做了该笔记，算是对Javascript知识体系的一个回顾和整理，但并没有把书中的代码直接copy&amp;paste，而是对技巧的罗列，其中对继承那部分，有一些自己的理解。</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://leozdgao.github.io/tags/javascript/"/>
    
      <category term="Javascript基础" scheme="http://leozdgao.github.io/categories/jsbasic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Reset及相关思考]]></title>
    <link href="http://leozdgao.github.io/2015/03/17/CSS-Reset%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%80%9D%E8%80%83/"/>
    <id>http://leozdgao.github.io/2015/03/17/CSS-Reset及相关思考/</id>
    <published>2015-03-17T12:55:13.000Z</published>
    <updated>2015-03-21T03:14:09.719Z</updated>
    <content type="html"><![CDATA[<p>有一个专门讲CSS Reset的站点。 <a href="http://www.cssreset.com/" target="_blank" rel="external">site</a></p>
<p>由于各大浏览器的user agent样式（即默认样式）不同，为了尽可能避免浏览器之间样式的差异，重置了css样式，让浏览器之间可以由一个基本相同的样式基准，并在该基准的基础上进行开发。</p>
<h2 id="引入CSS_Reset样式">引入CSS Reset样式</h2><p>引入CSS Reset，意味着告诉浏览器将所有元素应用上reset的样式，再使用针对页面或业务的特定样式。对于页面加载而言，这不算一个最优的方式，但对于组织css代码而言是一个好方法，因为页面针对不同浏览器都在一个统一的基准上开发。</p>
<p>而通常来说CSS Reset网上有许多现成的（可以去上面的链接里找），但直接引入或者直接复制黏贴不是推荐的做法，这里我直接引用：</p>
<blockquote>
<p>The reset styles given here are intentionally very generic. I don’t particularly recommend that you just use this in its unaltered state in your own projects. It should     be tweaked, edited, extended, and otherwise tuned to match your specific reset baseline. Fill in your preferred colors for the page, links, and so on. In other words, this is a starting point, not a self-contained black box of no-touchiness.</p>
</blockquote>
<p>简单地说，引入bootstrap后，即使html中没有定义任何class或者inline style，依然可以呈现出优雅的页面，即推荐大家根据自己的需求定制自己的CSS Reset，而不是直接拷贝（虽然确实省事）。</p>
<a id="more"></a>
<h2 id="CSS设计">CSS设计</h2><p>在为一个站点写css样式时，我认为可以分为三层：全局层，模块层，页面逻辑层。</p>
<p>全局层代表的是应用在所有页面上样式，模块层值的是应用在各个具有相同样式规则的元素上的，页面逻辑层是每个页面都不共享的一些特殊样式。而CSS Reset则可以作为全局层的一部分让所有页面具有相同的样式基准，对于模块层和页面逻辑层，举个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line">    <span class="comment">/*全局层*/</span></span><br><span class="line">    * <span class="rules">&#123; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0px</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0px</span></span></span>; <span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*模块层*/</span></span><br><span class="line">    <span class="class">.list</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> -<span class="number">10px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> -<span class="number">10px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br><span class="line">    <span class="class">.list</span> <span class="class">.list-item</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">padding-left</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">padding-right</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br><span class="line">    <span class="class">.list</span><span class="pseudo">:after</span>, <span class="class">.clearfix</span><span class="pseudo">:after</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">""</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">display</span>:<span class="value"> table</span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*页面逻辑层*/</span></span><br><span class="line">    <span class="class">.testlist</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#3c3c3c</span></span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list-item testlist"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list-item testlist"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list-item testlist"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list-item testlist"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"list-item testlist"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>list模块包括了样式<code>.list</code>、<code>.list-item</code>，可应用于一些需要呈现列表的情景，而<code>testlist</code>样式仅包含应用于特定场景的特殊样式。不难发现，CSS中的注释对代码维护有着重大意义。</p>
<h2 id="关于使用Universal_Selector(*)做CSS_Reset">关于使用Universal Selector(*)做CSS Reset</h2><p>使用全局选择器或者叫通配选择器(*)，是一种最简便的CSS Reset的方式，可能会是这样子的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>或许会在这个基础上再加上其他style的重设，比如<code>border: 0;</code>或者是<code>outline:0;</code>这样子。但这样子维护CSS Reset是有许多弊端的：</p>
<ul>
<li>没有明确的指出哪个元素是被reset的了，这个算是语义上的问题</li>
<li>样式继承将无法作用于任何元素，因为全局选择器会匹配所用的元素，其样式权值为<code>0,0,0,1</code>，而继承样式的权值为<code>&lt;0,0,0,1</code>，这也导致了子元素的样式需要重复的逐个定义（个人认为是主要隐患）</li>
<li>由于该选择器将匹配所有元素，可能会增加页面的加载时间（这个是有争议的观点）</li>
<li>IE6、IE7不支持该选择器</li>
</ul>
<p>由于使用这种reset的方式虽然简便，但可能会带来一些隐患，使用它时需要清楚的知道里面的样式规则是否会带来丢失继承的隐患，其实<code>Tripoli CSS Reset</code>中也是有部分样式是使用这个选择器的，大家根据需求自己权衡。</p>
<h2 id="小提示">小提示</h2><p>在写CSS Reset的时候应该要注意，比如我设置：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#333</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>那么导致的问题是需要每次手动设置a标签的<code>:focus</code>、<code>:hover</code>等样式，因为对a标签应用该样式会覆盖所有a标签的默认样式，包括伪类（伪类也被认为是应用于a标签的样式，伪类样式权值为<code>0,0,1,0</code>）。同样的问题也会出现在像<code>outline</code>这样的样式上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有一个专门讲CSS Reset的站点。 <a href="http://www.cssreset.com/">site</a></p>
<p>由于各大浏览器的user agent样式（即默认样式）不同，为了尽可能避免浏览器之间样式的差异，重置了css样式，让浏览器之间可以由一个基本相同的样式基准，并在该基准的基础上进行开发。</p>
<h2 id="引入CSS_Reset样式">引入CSS Reset样式</h2><p>引入CSS Reset，意味着告诉浏览器将所有元素应用上reset的样式，再使用针对页面或业务的特定样式。对于页面加载而言，这不算一个最优的方式，但对于组织css代码而言是一个好方法，因为页面针对不同浏览器都在一个统一的基准上开发。</p>
<p>而通常来说CSS Reset网上有许多现成的（可以去上面的链接里找），但直接引入或者直接复制黏贴不是推荐的做法，这里我直接引用：</p>
<blockquote>
<p>The reset styles given here are intentionally very generic. I don’t particularly recommend that you just use this in its unaltered state in your own projects. It should     be tweaked, edited, extended, and otherwise tuned to match your specific reset baseline. Fill in your preferred colors for the page, links, and so on. In other words, this is a starting point, not a self-contained black box of no-touchiness.</p>
</blockquote>
<p>简单地说，引入bootstrap后，即使html中没有定义任何class或者inline style，依然可以呈现出优雅的页面，即推荐大家根据自己的需求定制自己的CSS Reset，而不是直接拷贝（虽然确实省事）。</p>]]>
    
    </summary>
    
      <category term="css" scheme="http://leozdgao.github.io/tags/css/"/>
    
      <category term="HTML/CSS" scheme="http://leozdgao.github.io/categories/HTML-CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shebang]]></title>
    <link href="http://leozdgao.github.io/2015/03/01/Shebang/"/>
    <id>http://leozdgao.github.io/2015/03/01/Shebang/</id>
    <published>2015-03-01T03:25:35.000Z</published>
    <updated>2015-03-21T03:27:36.287Z</updated>
    <content type="html"><![CDATA[<p><a href="http://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="external">wiki</a>链接</p>
<p>在计算机科学中，Shebang（也称为Hashbang）是一个由井号和叹号构成的字符序列（<strong>#!</strong>），其出现在文本文件的第一行的前两个字符。 在文件中存在Shebang的情况下，类Unix操作系统的程序载入器会分析Shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有Shebang的文件路径作为该解释器的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span></span><br></pre></td></tr></table></figure>
<p>开头的文件在执行时会实际调用/bin/sh程序（通常是Bourne shell或兼容的shell，例如bash、dash等）来执行。</p>
<h2 id="语法">语法</h2><p>Shebang这一语法特性由<code>#!</code>开头，即井号和叹号。 在开头字符之后，可以有一个或数个空白字符，后接解释器的绝对路径，用于调用解释器。Shebang行也可以包含需要传递到解释器的特定选项。然而，选项传递的方式随实现的不同而不同。</p>
<p>使用<code>#!/usr/bin/env</code>脚本解释器名称是一种常见的在不同平台上都能正确找到解释器的办法。</p>
<p><strong>Node global bin</strong>：<code>#!/usr/bin/env node</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="external">wiki</a>链接</p>
<p>在计算机科学中，Shebang（也称为Hashbang）是一个由井号和叹号构成的字]]>
    </summary>
    
      <category term="linux" scheme="http://leozdgao.github.io/tags/linux/"/>
    
      <category term="操作系统基础" scheme="http://leozdgao.github.io/categories/os/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git Flow简介]]></title>
    <link href="http://leozdgao.github.io/2015/02/28/Git-Flow%E7%AE%80%E4%BB%8B/"/>
    <id>http://leozdgao.github.io/2015/02/28/Git-Flow简介/</id>
    <published>2015-02-28T03:13:19.000Z</published>
    <updated>2015-03-21T03:15:41.637Z</updated>
    <content type="html"><![CDATA[<p>摘抄自：<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">原文</a>，<a href="http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/" target="_blank" rel="external">译文</a></p>
<p><img src="http://7sbm5t.com1.z0.glb.clouddn.com/gitflow_0.png" alt="git flow"></p>
<a id="more"></a>
<h4 id="主要分支">主要分支</h4><ul>
<li>develop：反映了开发过程中最新的提交变更。</li>
<li>master：当develop分支的源码达到一个稳定的状态时，develop上的变更都应该以某种方式合并回master分支，每一个commit对应一个版本，并使用发布版本号打上标签。</li>
</ul>
<h4 id="特性分支">特性分支</h4><p>可能的分支来源：develop<br>必须合并回：develop<br>分支命名约定：任何除master，develop，release-*，或hotfix-*以外的名称</p>
<p>特性分支用来开发下个版本的新特性，最终会被合并回develop分支，往往只存在于开发者的仓库中，而不会出现在origin。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="blockquote">&gt; git checkout develop</span></span><br><span class="line">Switch to branch ‘develop’</span><br><span class="line"><span class="blockquote">&gt; git merge -no-ff myfeature</span></span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="blockquote">&gt; git branch -d myfeature</span></span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line"><span class="blockquote">&gt; git push origin develop</span></span><br></pre></td></tr></table></figure>
<h4 id="发布分支">发布分支</h4><p>可能的分支来源：develop<br>必须合并回：develop和master<br>分支命名约定：release-*</p>
<p>发布分支为准备新的产品版本发布做支持，它允许你在最后时刻检查所有的细节。在分布分支创建的时候，对应的版本发布才获得一个版本号。</p>
<p><strong>创建一个发布分支</strong></p>
<p>发布分支从develop分支创建，develop分支的状态已经是准备好“下一版本”发布了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; git checkout -<span class="tag">b</span> releases-<span class="number">1.2</span> develop</span><br><span class="line">Switched to <span class="tag">a</span> new branch “release-<span class="number">1.2</span>”</span><br><span class="line">&gt; ./bump-version<span class="class">.sh</span> <span class="number">1.2</span></span><br><span class="line">Files modified successfully. version bumped to <span class="number">1.2</span>.</span><br><span class="line">&gt; git commit -<span class="tag">a</span> -m “Bumped version number to <span class="number">1.2</span>”</span><br><span class="line">[release-<span class="number">1.2</span> <span class="number">74</span>d9424] Bumped version number to <span class="number">1.2</span></span><br><span class="line"><span class="number">1</span> files changed. <span class="number">1</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>. <span class="number">1</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>结束一个发布分支</strong></p>
<p>当发布分支达到一个可以正式发布的状态时，将发布分支合并到master，接着master分支上的commit必须被打上标签（tag）。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch ‘master’</span><br><span class="line">&gt; git <span class="built_in">merge</span> –no-ff release-<span class="number">1.2</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br><span class="line">&gt; git tag -<span class="operator">a</span> <span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<p>为了能保留发布分支上的变更，我们还需要将分支合并回develop。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch ‘develop’</span><br><span class="line">&gt; git <span class="built_in">merge</span> –no-ff release-<span class="number">1.2</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br></pre></td></tr></table></figure>
<p>现在工作才算真正完成了，最后一步是删除发布分支。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">&gt;</span> git branch <span class="keyword">-</span>d <span class="keyword">release</span><span class="keyword">-</span><span class="number">1</span><span class="typename">.2</span></span><br><span class="line">Deleted branch <span class="keyword">release</span><span class="keyword">-</span><span class="number">1</span><span class="typename">.2</span> (was ff452fe).</span><br></pre></td></tr></table></figure>
<h4 id="热补丁分支">热补丁分支</h4><p>可能的分支来源：master<br>必须合并回：develop和master<br>分支命名约定：hotfix-*</p>
<p>当产品版本发现未预期的问题时，需要着手处理，这时就需要热补丁分支。</p>
<p><strong>创建一个热补丁分支</strong></p>
<p>热补丁分支从master分支创建。不要忘记在创建热补丁分支后设定一个新的版本号。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; git checkout -<span class="tag">b</span> hotfix-<span class="number">1.2</span>.<span class="number">1</span> master</span><br><span class="line">Switched to <span class="tag">a</span> new branch “hotfix-<span class="number">1.2</span>.<span class="number">1</span>″</span><br><span class="line">&gt; ./bump-version<span class="class">.sh</span> <span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">Files modified successfully, version bumped to <span class="number">1.2</span>.<span class="number">1</span>.</span><br><span class="line">&gt; git commit -<span class="tag">a</span> -m “Bumped version number to <span class="number">1.2</span>.<span class="number">1</span>″</span><br><span class="line">[hotfix-<span class="number">1.2</span>.<span class="number">1</span> <span class="number">41</span>e61bb] Bumped version number to <span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line"><span class="number">1</span> files changed, <span class="number">1</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>, <span class="number">1</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<p>修复bug并提交。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git commit -m “Fixed severe production problem”</span><br><span class="line">[hotfix-<span class="number">1.2</span>.<span class="number">1</span> abbe5d6] Fixed severe production problem</span><br><span class="line"><span class="number">5</span> files changed, <span class="number">32</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>, <span class="number">17</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>结束一个热补丁分支</strong></p>
<p>修复完成后，热补丁分支需要合并回master并打上标签，同时也需要被合并回develop。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch ‘develop’</span><br><span class="line">&gt; git <span class="built_in">merge</span> –no-ff hotfix-<span class="number">1.2</span><span class="number">.1</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br></pre></td></tr></table></figure>
<p><em>注：如果这个时候有发布分支存在，热补丁分支的变更则应该合并至发布分支，而不是develop。</em></p>
<p>最后删除临时的热补丁分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; git branch <span class="operator">-d</span> hotfix-<span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">Deleted branch hotfix-<span class="number">1.2</span>.<span class="number">1</span> (was abbe5d6).</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>摘抄自：<a href="http://nvie.com/posts/a-successful-git-branching-model/">原文</a>，<a href="http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/">译文</a></p>
<p><img src="http://7sbm5t.com1.z0.glb.clouddn.com/gitflow_0.png" alt="git flow"></p>]]>
    
    </summary>
    
      <category term="git" scheme="http://leozdgao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React JSX语法说明]]></title>
    <link href="http://leozdgao.github.io/2015/02/21/React-JSX%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/"/>
    <id>http://leozdgao.github.io/2015/02/21/React-JSX语法说明/</id>
    <published>2015-02-21T03:17:00.000Z</published>
    <updated>2015-03-21T03:19:45.445Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是JSX？">什么是JSX？</h2><p>在用React写组件的时候，通常会用到JSX语法，粗看上去，像是在Javascript代码里直接写起了XML标签，实质上这只是一个<strong>语法糖</strong>，每一个XML标签都会被JSX转换工具转换成纯Javascript代码，当然你想直接使用纯Javascript代码写也是可以的，只是利用JSX，组件的结构和组件之间的关系看上去更加清晰。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var MyComponent = React.createClass(&#123;/*<span class="keyword">...</span>*/&#125;);</span><br><span class="line">var myElement = &lt;MyComponent someProperty=&#123;true&#125; /&gt;;</span><br><span class="line">React.render(myElement, document.body);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>一个XML标签，比如<code>&lt;MyComponent someProperty={true} /&gt;</code>会被JSX转换工具转换成什么呢？</p>
<p>比如：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var Nav = React.createClass(&#123;/*<span class="keyword">...</span>*/&#125;);</span><br><span class="line">var app = &lt;Nav color=<span class="string">"blue"</span>&gt;&lt;Profile&gt;click&lt;/Profile&gt;&lt;/Nav&gt;;</span><br></pre></td></tr></table></figure></p>
<p>会被转化为：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Nav = React.createClass(&#123;/*<span class="keyword">...</span>*/&#125;);</span><br><span class="line">var app = React.createElement(</span><br><span class="line">    Nav,</span><br><span class="line">    &#123;color:<span class="string">"blue"</span>&#125;,</span><br><span class="line">    React.createElement(Profile, null, <span class="string">"click"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>那么也就是说，我们写一个XML标签，实质上就是在调用<code>React.createElement</code>这个方法，并返回一个<code>ReactElement</code>对象。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactElement createElement(</span><br><span class="line">    string/ReactClass type,</span><br><span class="line">    [object props],</span><br><span class="line">    [children <span class="keyword">...</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个方法的第一个参数可以是一个字符串，表示是一个HTML标准内的元素，或者是一个<code>ReactClass</code>类型的对象，表示我们之前封装好的自定义组件。第二个参数是一个对象，或者说是字典也可以，它保存了这个元素的所有固有属性（即传入后基本不会改变的值）。从第三个参数开始，之后的参数都被认作是元素的子元素。</p>
<h2 id="JSX转化器">JSX转化器</h2><p>要把带有JSX语法的代码转化为纯Javascript代码，有多种方式，对于内联与HTML中的代码或者是未经过转化的外部文件，在<code>script</code>标签中要加上<code>type=&quot;text/jsx&quot;</code>，并引入<code>JSXTransformer.js</code>文件即可，不过这种方式并不建议在生产环境使用，建议的方法是在代码上线前就将代码转换好，可以使用<code>npm</code><strong>全局安装</strong><code>react-tools</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g react-tools</span><br></pre></td></tr></table></figure>
<p>并使用命令行工具转化即可（具体用法可以参考<code>jsx -h</code>）：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsx src<span class="regexp">/ build/</span></span><br></pre></td></tr></table></figure>
<p>如果使用自动化工具，比如<code>gulp</code>的话，可以使用相应插件<code>gulp-react</code>。</p>
<h2 id="使用HTML标签">使用HTML标签</h2><p>要创建一个HTML标准中存在的元素，直接像写HTML代码一样即可：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> myDivElement = &lt;div className=<span class="string">"foo"</span> /&gt;;</span><br><span class="line">React.render(myDivElement, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p>不过需要注意的是<code>class</code>和<code>for</code>这两个属性，JSX语法最终是要被转换为纯Javascript的，所以要和在Javascript DOM中一样，用<code>className</code>和<code>htmlFor</code>。</p>
<p>还有一点是，在创建HTML标准内的元素时，JSX转化器会丢弃那些非标准的属性，如果一定要添加自定义属性，那么需要在这些自定义属性之前添加<code>data-</code>前缀。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">div</span> data-custom-attribute=<span class="string">"foo"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="命名空间式组件">命名空间式组件</h2><p>比如开发组件的时候，一个组件有多个子组件，你希望这些子组件可以作为其父组件的属性，那么可以像这样用：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">Form</span> = MyFormComponent;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="keyword">App</span> = (</span><br><span class="line">  &lt;<span class="keyword">Form</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">Form</span>.Row&gt;</span><br><span class="line">      &lt;<span class="keyword">Form</span>.<span class="keyword">Label</span> /&gt;</span><br><span class="line">      &lt;<span class="keyword">Form</span>.<span class="keyword">Input</span> /&gt;</span><br><span class="line">    &lt;/<span class="keyword">Form</span>.Row&gt;</span><br><span class="line">  &lt;/<span class="keyword">Form</span>&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样你只需将子组件的<code>ReactClass</code>作为其父组件的属性：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var MyFormComponent = React.createClass(&#123; <span class="keyword">...</span> &#125;);</span><br><span class="line"> </span><br><span class="line">MyFormComponent.Row = React.createClass(&#123; <span class="keyword">...</span> &#125;);</span><br><span class="line">MyFormComponent.Label = React.createClass(&#123; <span class="keyword">...</span> &#125;);</span><br><span class="line">MyFormComponent.Input = React.createClass(&#123; <span class="keyword">...</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>而创建子元素可以直接交给JSX转化器：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">App</span> = (</span><br><span class="line">    React.createElement(<span class="keyword">Form</span>, null,</span><br><span class="line">        React.createElement(<span class="keyword">Form</span>.Row, null,</span><br><span class="line">            React.createElement(<span class="keyword">Form</span>.<span class="keyword">Label</span>, null),</span><br><span class="line">            React.createElement(<span class="keyword">Form</span>.<span class="keyword">Input</span>, null)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><em>该功能需要0.11及以上版本</em></p>
<h2 id="Javascript表达式">Javascript表达式</h2><p>在JSX语法中写Javascript表达式只需要用<code>{}</code>即可，比如下面这个使用三目运算符的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input (JSX):</span></span><br><span class="line"><span class="keyword">var</span> content = &lt;Container&gt;&#123;<span class="built_in">window</span>.isLoggedIn ? &lt;Nav /&gt; : &lt;Login /&gt;&#125;&lt;/Container&gt;;</span><br><span class="line"><span class="comment">// Output (JS):</span></span><br><span class="line"><span class="keyword">var</span> content = React.createElement(</span><br><span class="line">    Container,</span><br><span class="line">    <span class="keyword">null</span>,</span><br><span class="line">    <span class="built_in">window</span>.isLoggedIn ? React.createElement(Nav) : React.createElement(Login)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>不过要注意的是，JSX语法只是语法糖，它的背后是调用<code>ReactElement</code>的构造方法<code>React.createElement</code>的，所以类似这样的写法是不可以的：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This JSX:</span></span><br><span class="line">&lt;<span class="keyword">div</span> id=&#123;<span class="keyword">if</span> (condition) &#123; <span class="string">'msg'</span> &#125;&#125;&gt;Hello World!&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Is transformed to this JS:</span></span><br><span class="line">React.createElement(<span class="string">"div"</span>, &#123;id: <span class="keyword">if</span> (condition) &#123; <span class="string">'msg'</span> &#125;&#125;, <span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure>
<p>可以从转化后的Javascript代码中看出明显的语法错误，所以要不用三目运算符，要不就这样写：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &lt;<span class="keyword">div</span> <span class="property">id</span>='msg'&gt;Hello World!&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"><span class="keyword">else</span> &lt;<span class="keyword">div</span>&gt;Hello World!&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="传播属性（Spread_Attributes）">传播属性（Spread Attributes）</h2><p>在JSX中，可以使用<code>...</code>运算符，表示将一个对象的键值对与<code>ReactElement</code>的<code>props</code>属性合并，这个<code>...</code>运算符的实现类似于ES6 Array中的<code>...</code>运算符的特性。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> props <span class="subst">=</span> &#123; foo: x, bar: y &#125;;</span><br><span class="line"><span class="built_in">var</span> component <span class="subst">=</span> <span class="subst">&lt;</span>Component &#123; <span class="attribute">...</span>props &#125; <span class="subst">/</span><span class="subst">&gt;</span>;</span><br></pre></td></tr></table></figure>
<p>这样就相当于：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var component = <span class="tag">&lt;<span class="title">Component</span> <span class="attribute">foo</span>=<span class="value">&#123;x&#125;</span> <span class="attribute">bar</span>=<span class="value">&#123;y&#125;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>它也可以和普通的XML属性混合使用，需要同名属性，后者将覆盖前者：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> props <span class="subst">=</span> &#123; foo: <span class="string">'default'</span> &#125;;</span><br><span class="line"><span class="built_in">var</span> component <span class="subst">=</span> <span class="subst">&lt;</span>Component &#123;<span class="attribute">...</span>props&#125; foo<span class="subst">=</span>&#123;<span class="string">'override'</span>&#125; <span class="subst">/</span><span class="subst">&gt;</span>;</span><br><span class="line">console<span class="built_in">.</span><span class="keyword">log</span>(component<span class="built_in">.</span>props<span class="built_in">.</span>foo); <span class="comment">// 'override'</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料（可能无法直接打开链接）">参考资料（可能无法直接打开链接）</h2><ul>
<li><a href="http://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX in Depth</a></li>
<li><a href="http://facebook.github.io/react/docs/jsx-spread.html" target="_blank" rel="external">JSX Spread Attributes</a></li>
<li><a href="http://facebook.github.io/react/tips/if-else-in-JSX.html" target="_blank" rel="external">If-Else in JSX</a></li>
<li><a href="http://facebook.github.io/react/docs/jsx-gotchas.html" target="_blank" rel="external">JSX Gotchas</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是JSX？">什么是JSX？</h2><p>在用React写组件的时候，通常会用到JSX语法，粗看上去，像是在Javascript代码里直接写起了XML标签，实质上这只是一个<strong>语法糖</strong>，每一个XML标签都会被JSX转换工具转换成纯Javascript代码，当然你想直接使用纯Javascript代码写也是可以的，只是利用JSX，组件的结构和组件之间的关系看上去更加清晰。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var MyComponent = React.createClass(&#123;/*<span class="keyword">...</span>*/&#125;);</span><br><span class="line">var myElement = &lt;MyComponent someProperty=&#123;true&#125; /&gt;;</span><br><span class="line">React.render(myElement, document.body);</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="react.js" scheme="http://leozdgao.github.io/tags/react-js/"/>
    
      <category term="JS类库探索" scheme="http://leozdgao.github.io/categories/jslibs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IP协议相关技术]]></title>
    <link href="http://leozdgao.github.io/2015/02/20/IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    <id>http://leozdgao.github.io/2015/02/20/IP协议相关技术/</id>
    <published>2015-02-20T03:29:39.000Z</published>
    <updated>2015-03-21T03:35:45.721Z</updated>
    <content type="html"><![CDATA[<h2 id="DNS（Domain_Name_System）">DNS（Domain Name System）</h2><p>直接使用IP地址有诸多不便，而DNS系统是一个可以有效管理主机名和IP地址之间对应关系的系统。</p>
<p><strong>域名</strong>是指为了识别主机名称和组织机构名称的一种具有分层的名称。<strong>域名服务器</strong>是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。根部所设置的DNS叫做根域名服务器，根域名服务器中注册着根以下第一层域名服务器的IP地址，类似地，在根域名服务器的下一层域名服务器中注册了再往下一层域名服务器的IP地址。</p>
<p>DNS查询：为了调查IP地址，向本机注册的域名服务器进行查询处理，接收请求的域名服务器首先会先在自己的数据库进行查找，如果查到结果，就返回对应的IP地址，如果没有，则域名服务器再向上一层域名服务器进行查询，直到查询到指定的域名服务器并由这个域名服务器返回想要的数据。解析器和域名服务器将最新了解到的信息暂时保存在缓存里以减少每次查询时的性能消耗。</p>
<a id="more"></a>
<p>DNS不仅仅管理主机名和IP地址的映射关系，还有众多其他信息：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编号</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1</td>
<td>主机名的IP地址（IPv4）</td>
</tr>
<tr>
<td>NS</td>
<td>2</td>
<td>域名服务器</td>
</tr>
<tr>
<td>CNAME</td>
<td>5</td>
<td>主机别名对应的规范名称</td>
</tr>
<tr>
<td>SOA</td>
<td>6</td>
<td>区域内权威记录起始标志</td>
</tr>
<tr>
<td>WKS</td>
<td>11</td>
<td>已知的服务</td>
</tr>
<tr>
<td>PTR</td>
<td>12</td>
<td>IP地址反向解析</td>
</tr>
<tr>
<td>HINFO</td>
<td>13</td>
<td>主机相关的追加信息</td>
</tr>
<tr>
<td>MINFO</td>
<td>14</td>
<td>邮箱与邮件组信息</td>
</tr>
<tr>
<td>MX</td>
<td>15</td>
<td>邮件交换</td>
</tr>
<tr>
<td>TXT</td>
<td>16</td>
<td>文本</td>
</tr>
<tr>
<td>SIG</td>
<td>24</td>
<td>安全证书</td>
</tr>
<tr>
<td>KEY</td>
<td>25</td>
<td>密钥</td>
</tr>
<tr>
<td>GPOS</td>
<td>27</td>
<td>地理位置</td>
</tr>
<tr>
<td>AAAA</td>
<td>28</td>
<td>主机的IPv6地址</td>
</tr>
<tr>
<td>NXT</td>
<td>30</td>
<td>下一代域名</td>
</tr>
<tr>
<td>SRV</td>
<td>33</td>
<td>服务器选择</td>
</tr>
<tr>
<td>*</td>
<td>255</td>
<td>所有缓存记录</td>
</tr>
</tbody>
</table>
<h2 id="ARP（Address_Resolution_Protocol）">ARP（Address Resolution Protocol）</h2><p>ARP是一种解决地址问题的协议，以目标IP地址为线索，用来定位下一个应该接受数据分包的网络设备对应的MAC地址。如果目标主机不在同一个链路上，则通过ARP查找下一跳路由器的MAC地址。</p>
<p>ARP工作机制：起初要通过广播发送一个ARP请求包，这个包包含了想要了解其MAC地址的IP地址。如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机。第一次通过ARP请求获取到的MAC地址作为IP对MAC的映射关系记忆到一个ARP缓存表中，反之，接收ARP请求的那个主机又可以从这个ARP请求包获取发送端主机的IP地址及其MAC地址并记入缓存，以提高效率。</p>
<p>RARP（Reverse Address Resolution Protocol）是将ARP反过来，根据MAC地址定位IP地址的一种协议。为此需要架设一台RARP服务器，在这个服务器上注册设备的MAC地址及其IP地址。然后再将这个设备接入到网络时，会发送RARP请求，RARP服务器接收到后，返回相应的注册信息。</p>
<p>ARP只适用于IPv4，不能用于IPv6，IPv6中可以用ICMPv6替代ARP发送邻居探索消息。</p>
<h2 id="ICMP">ICMP</h2><p>ICMP的主要功能包括确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。在IP通信中如果某个IP包因为某种原因未能达到目标地址，那么这个具体的原因将由ICMP负责通知，ICMP的通知消息会使用IP进行发送。</p>
<p>ICMP消息类型：</p>
<table>
<thead>
<tr>
<th>类型（十进制数）</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>回送应答</td>
</tr>
<tr>
<td>3</td>
<td>目标不可达</td>
</tr>
<tr>
<td>4</td>
<td>原点抑制</td>
</tr>
<tr>
<td>5</td>
<td>重定向或改变路由</td>
</tr>
<tr>
<td>8</td>
<td>回送请求</td>
</tr>
<tr>
<td>9</td>
<td>路由器公告</td>
</tr>
<tr>
<td>10</td>
<td>路由器请求</td>
</tr>
<tr>
<td>11</td>
<td>超时</td>
</tr>
<tr>
<td>17</td>
<td>地址子网请求</td>
</tr>
<tr>
<td>18</td>
<td>地址子网应答</td>
</tr>
</tbody>
</table>
<p><strong>ICMPv6</strong>：在IPv6中，ICMP的作用被扩大，IP地址定位MAC地址的协议从ARP转为ICMP的邻居探索消息。这种邻居探索消息融合了IPv4的ARP、ICMP重定向以及ICMP路由器选择消息等功能于一体。邻居请求消息利用IPv6的多播地址，查询IPv6的地址与MAC地址的对应关系，并由邻居宣告消息得知MAC地址。</p>
<h2 id="DHCP（Dynamic_Host_Configuration_Protocol）">DHCP（Dynamic Host Configuration Protocol）</h2><p>DHCP用于自动设置IP地址、统一管理IP地址分配。使用DHCP之前，首先要架设一台DHCP服务器（通常该网段的路由器充当了DHCP服务器）。然后将DHCP要分配的IP地址、子网掩码、路由控制信息以及DNS服务器地址等设置到服务器上。</p>
<p>DHCP工作机制：首先DHCP客户端发送DHCP发现包要求设置IP地址和子网掩码，接下来DHCP服务器发送DHCP提供包通知其可以使用的网络设置，然后客户端发送DHCP请求包通知想要使用之前返回的网络设置，最后服务器发送DHCP提供包通知允许其设置。</p>
<p>为了检查所要分配的IP地址以及分配了的IP地址是否可用，需要具备以下功能：</p>
<ul>
<li>DHCP服务器：在分配IP底之前发送ICMP回送请求包，确认没有返回应答。</li>
<li>DHCP客户端：针对从DHCP那里获得的IP地址发送ARP请求包，确认没有返回应答。</li>
</ul>
<p><strong>DHCP中继代理</strong>对不同网段的IP地址分配也可以由一个DHCP服务器统一进行管理和运维。</p>
<h2 id="NAT（Network_Address_Translator）">NAT（Network Address Translator）</h2><p>用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。除了转换IP地址外，还出现了可以转换TCP、UDP端口号的<strong>NAPT</strong>技术。</p>
<p>NAT工作机制：利用NAT，途中的NAT路由器将发送源地址转换为全局IP地址再发送数据，反之，当包从发过来时，目标地址先被转换成私有IP地址以后再被转发。</p>
<h2 id="IP隧道">IP隧道</h2><p>在网络层的首部后面继续追加网络层首部的通信方式叫做IP隧道。</p>
<p><strong>Mobile IP</strong>在主机所连接的子网IP发生变化时，主机IP地址仍保持不变，即使在IP地址发生变化的环境下，通信也能够继续。Mobile IP中的移动主机，在移动之前按照以往的模式进行通信，而移动之后则通过外部代理发送转发数据包向归属代理通知自己的地址。通信对端主机在目标主机移动后，发送ARP消息，并接收以移动主机为目标地址的数据包，归属代理采用IP隧道转发给移动主机，外部代理将IP头删除还原为原始数据包。</p>
<h2 id="其他IP相关技术">其他IP相关技术</h2><ul>
<li><p>IP多播相关技术<br>IGMP（MLD）用于多播过程中确认接收端，主要有两大作用：</p>
<ol>
<li>向路由器表明想要接收多播消息并通知想接收多播的地址。</li>
<li>向交换集线器通知想要接收多播的地址。</li>
</ol>
</li>
<li><p>IP任播<br>IP任播是指为那些提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信的一种方法，适用于IPv4和IPv6。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="DNS（Domain_Name_System）">DNS（Domain Name System）</h2><p>直接使用IP地址有诸多不便，而DNS系统是一个可以有效管理主机名和IP地址之间对应关系的系统。</p>
<p><strong>域名</strong>是指为了识别主机名称和组织机构名称的一种具有分层的名称。<strong>域名服务器</strong>是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。根部所设置的DNS叫做根域名服务器，根域名服务器中注册着根以下第一层域名服务器的IP地址，类似地，在根域名服务器的下一层域名服务器中注册了再往下一层域名服务器的IP地址。</p>
<p>DNS查询：为了调查IP地址，向本机注册的域名服务器进行查询处理，接收请求的域名服务器首先会先在自己的数据库进行查找，如果查到结果，就返回对应的IP地址，如果没有，则域名服务器再向上一层域名服务器进行查询，直到查询到指定的域名服务器并由这个域名服务器返回想要的数据。解析器和域名服务器将最新了解到的信息暂时保存在缓存里以减少每次查询时的性能消耗。</p>]]>
    
    </summary>
    
      <category term="计算机网络基础" scheme="http://leozdgao.github.io/categories/net/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP与UDP]]></title>
    <link href="http://leozdgao.github.io/2015/02/20/TCP%E4%B8%8EUDP/"/>
    <id>http://leozdgao.github.io/2015/02/20/TCP与UDP/</id>
    <published>2015-02-20T03:28:37.000Z</published>
    <updated>2015-03-21T03:36:09.594Z</updated>
    <content type="html"><![CDATA[<h2 id="传输层定义">传输层定义</h2><p>传输层使用<strong>端口号</strong>这样一种识别码来识别在传输层上一层的应用层中所要进行处理的具体程序。</p>
<p>在TCP/IP中能够实现传输层功能的、具有代表性的协议：</p>
<ul>
<li>TCP：面向连接的、可靠的流协议，用于在传输层有必要实现可靠传输的情况。</li>
<li>UDP：不具有可靠性的数据报歇息，细微的处理会交给上层的应用去完成，主要用于那些对高速传输和实时性有较高要求的通信或广播通信。</li>
</ul>
<h2 id="端口号">端口号</h2><p>TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。它们是“源IP地址”、“目标IP地址”、“协议号”、“源端口地址”、“目标端口地址”。</p>
<p>确定端口的两种方法：</p>
<ol>
<li>静态方法<br>每个应用程序都有其指定的端口号。应用程序应该避免使用0到1023的知名端口号。</li>
<li>时序分配法<br>客户端应用程序可以不用自己设置端口号，操作系统可以为每个应用程序分配互不冲突的端口号，动态分配的端口号取值范围在49152到65535之间。</li>
</ol>
<p>数据到达IP层后，会先检查IP首部中的协议号，再传给相应协议的模块。即使是同一个端口号，由于传输协议是各自独立地进行处理，因此相互之间不受影响。此外，那些知名端口号与传输层协议并无关系，只要端口一致，都将分配同一种程序进行处理。</p>
<a id="more"></a>
<h2 id="UDP">UDP</h2><p>User Datagram Protocol，不提供复杂的控制机制，利用IP提供面向无连接的通信服务。常用于：</p>
<ul>
<li>包总量较少的通信（DNS、SNMP等）</li>
<li>视频、音频等多媒体通信（即使通信）</li>
<li>限定于LAN等特定网络中的应用通信</li>
<li>广播通信（广播、多播）</li>
</ul>
<h2 id="TCP">TCP</h2><p>TCP充分地实现了数据传输时各种控制功能，并作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，在IP这种无连接的网络上也能够实现高可靠性的通信。</p>
<p><strong>通过序列号与确认应答提高可靠性</strong>：<br>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做<strong>确认应答</strong>（ACK）。TCP通过肯定的确认应答（ACK）实现可靠的数据传输，当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端，反之，则数据丢失的可能性很大。当然，也可能是数据对方已经收到，只是返回的确认应答在途中丢失，这种情况也会导致发送端因没有收到确认应答，而认为数据没有到达目的地，从而进行重新发送。<br>确认应答处理、重发控制以及重复控制等功能都可以通过<strong>序列号</strong>实现。序列号按顺序给发送数据的每个字节标上号码，接收端查询数据TCP首部中的序列号和数据长度，将自己下一步应该接受的序号作为确认应答返送回去。</p>
<p><strong>连接管理</strong>：</p>
<p>在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答，如果对端发来确认应答，则认为可以进行数据通信，然后再向对端发送一个ACK包完成连接。在建立连接的过程中，要确定发送数据包的单位，最大消息长度（MSS）。TCP在传送大量数据时，是以MSS的大小将数据进行分割发送，MSS在三次握手时在两端主机之间被计算得出。</p>
<p><strong>利用窗口控制提高速度</strong></p>
<p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值，在收到确认应答的情况下，将窗口滑动到确认应答中的序列号位置，就可以顺序地将多个段同时发送提高通信性能，这种机制被称为<strong>滑动窗口控制</strong>，如果某个报文丢失的情况下，发送端主机如果连续3次收到同一个确认应答，就会将其所对应的数据进行重发。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="传输层定义">传输层定义</h2><p>传输层使用<strong>端口号</strong>这样一种识别码来识别在传输层上一层的应用层中所要进行处理的具体程序。</p>
<p>在TCP/IP中能够实现传输层功能的、具有代表性的协议：</p>
<ul>
<li>TCP：面向连接的、可靠的流协议，用于在传输层有必要实现可靠传输的情况。</li>
<li>UDP：不具有可靠性的数据报歇息，细微的处理会交给上层的应用去完成，主要用于那些对高速传输和实时性有较高要求的通信或广播通信。</li>
</ul>
<h2 id="端口号">端口号</h2><p>TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。它们是“源IP地址”、“目标IP地址”、“协议号”、“源端口地址”、“目标端口地址”。</p>
<p>确定端口的两种方法：</p>
<ol>
<li>静态方法<br>每个应用程序都有其指定的端口号。应用程序应该避免使用0到1023的知名端口号。</li>
<li>时序分配法<br>客户端应用程序可以不用自己设置端口号，操作系统可以为每个应用程序分配互不冲突的端口号，动态分配的端口号取值范围在49152到65535之间。</li>
</ol>
<p>数据到达IP层后，会先检查IP首部中的协议号，再传给相应协议的模块。即使是同一个端口号，由于传输协议是各自独立地进行处理，因此相互之间不受影响。此外，那些知名端口号与传输层协议并无关系，只要端口一致，都将分配同一种程序进行处理。</p>]]>
    
    </summary>
    
      <category term="计算机网络基础" scheme="http://leozdgao.github.io/categories/net/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用React创建评论区（Comment Box）组件]]></title>
    <link href="http://leozdgao.github.io/2015/02/19/%E5%88%A9%E7%94%A8React%E5%88%9B%E5%BB%BA%E8%AF%84%E8%AE%BA%E5%8C%BA%EF%BC%88Comment-Box%EF%BC%89%E7%BB%84%E4%BB%B6/"/>
    <id>http://leozdgao.github.io/2015/02/19/利用React创建评论区（Comment-Box）组件/</id>
    <published>2015-02-19T03:20:49.000Z</published>
    <updated>2015-03-21T03:22:57.169Z</updated>
    <content type="html"><![CDATA[<p>本文是在阅读学习了官方的<a href="http://facebook.github.io/react/docs/tutorial.html" target="_blank" rel="external">React Tutorial</a>之后的整理，实例<a href="http://7sbm5t.com1.z0.glb.clouddn.com/react0_ex.html" target="_blank" rel="external">链接</a>。</p>
<h2 id="开始使用React">开始使用React</h2><p>首先从官方获取React.js的最新版本（<a href="http://facebook.github.io/react/downloads.html" target="_blank" rel="external">v0.12.2</a>），或者下载官方的<a href="http://facebook.github.io/react/downloads/react-0.12.2.zip" target="_blank" rel="external">Starter Kit</a>，并在我们的html中引入它们：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>React Test Page<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../build/react.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../build/JSXTransformer.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="JSX语法">JSX语法</h2><p>我们可以在React组件的代码中发现xml标签似乎直接写进了javascript里：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React.render(</span><br><span class="line">    &lt;CommentBox /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这种写法被称作JSX，是React的一个可选功能，将xml标签直接写在javascript中看上去比调用javascript方法要更加直观些。要正常使用这个功能，需要在你的页面中引入<code>JSXTransformer.js</code>文件，或者使用<code>npm</code>安装<code>react-tools</code>，将包含JSX语法的源文件编译成常规的javascript文件，比较推荐的是后者，因为使用后者让页面可以直接使用编译后的javascript文件而不需要在加载页面时进行JSX编译。</p>
<p>JSX中的类HTML标签并不是真正的HTML元素，也不是一段HTML字符串，而是实例化了的React组件，关于JSX语法的更多内容，可以看这篇文章。</p>
<a id="more"></a>
<h2 id="创建组件">创建组件</h2><p>React可以为我们创建模块化、可组合的组件，对于我们需要做的评论区，我们的组件结构如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> <span class="constant">CommentBox</span></span><br><span class="line"></span>    -<span class="ruby"> <span class="constant">CommentList</span></span><br><span class="line"></span>        -<span class="ruby"><span class="constant">Comment</span></span><br><span class="line"></span>    -<span class="ruby"> <span class="constant">CommentForm</span></span></span><br></pre></td></tr></table></figure></p>
<p>通过<code>React.createClass()</code>可以一个React元素，我们可以像这样定义我们的CommentBox，并通过<code>React.render()</code>方法可以让我们在指定的容器中将React元素渲染为一个DOM组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"content"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/jsx"</span>&gt;</span><span class="javascript"></span><br><span class="line">        <span class="keyword">var</span> CommentBox = React.createClass(&#123;</span><br><span class="line">            render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"contentBox"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Comments<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">CommentList</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">CommentForm</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        React.render(</span><br><span class="line">            <span class="tag">&lt;<span class="title">CommentBox</span> /&gt;</span>,</span><br><span class="line">            document.getElementById('content')</span><br><span class="line">        );</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从这个例子也可以看出一个组件可以包含子组件，组件之间是可以组合的（Composing），并呈现一个树形结构，也可以说render方法中的的CommentBox代表的是组件树的根元素。那么接下来我们来创建CommentList和CommentForm这两个子组件。</p>
<p>首先是CommentList组件，这个组件是用来呈现评论列表的，根据开始我们设计的组件结构树，这个组件应该是包含许多Comment子组件的，那么，假设我们已经获取到评论数据了：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var comments = [</span><br><span class="line">    &#123;<span class="string">author:</span> <span class="string">"Pete Hunt"</span>, <span class="string">text:</span> <span class="string">"This is one comment"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">author:</span> <span class="string">"Jordan Walke"</span>, <span class="string">text:</span> <span class="string">"This is *another* comment"</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>我们需要把数据传递给CommentList组件才能让它去呈现，那么如何传递呢？我们可以通过<code>this.props</code>来访问组件标签上的属性，比如我们在CommentBox组件的代码中做如下修改：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">CommentList</span> <span class="attribute">data</span>=<span class="value">comments</span>  /&gt;</span></span><br></pre></td></tr></table></figure>
<p>于是在CommentList组件中，我们可以通过访问<code>this.props.data</code>来获取到我们的评论数据。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> commentNodes = <span class="keyword">this</span>.props.data.map(<span class="function"><span class="keyword">function</span><span class="params">(comment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;Comment author=&#123;comment.author&#125;&gt;</span><br><span class="line">                    &#123;comment.text&#125;</span><br><span class="line">                &lt;/Comment&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"commentList"</span>&gt;</span><br><span class="line">                &#123;commentNodes&#125;       </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接下来写Comment组件，这个组件用于呈现单个评论，我们希望它可以支持markdown语法，于是我们引入<a href="https://github.com/showdownjs/showdown" target="_blank" rel="external">showdown</a>这个库，在HTML中引入它之后，我们可以调用它让我们的评论支持Markdown语法。在这里我们需要<code>this.props.children</code>这个属性，它返回了该组件标签里的所有子元素。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> converter = <span class="keyword">new</span> Showdown.converter();</span><br><span class="line"><span class="keyword">var</span> Comment = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"comment"</span>&gt;</span><br><span class="line">                &lt;h2 className=<span class="string">"commentAuthor"</span>&gt;</span><br><span class="line">                    &#123;<span class="keyword">this</span>.props.author&#125;</span><br><span class="line">                &lt;/h2&gt;</span><br><span class="line">                &#123;converter.makeHtml(<span class="keyword">this</span>.props.children.toString())&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们看一下现在的效果：<br><img src="http://7sbm5t.com1.z0.glb.clouddn.com/react0_pic0.png" alt="效果"></p>
<p>我们发现经过解析后html标签被直接呈现了上去，因为React默认是有XSS保护的，所有对呈现的内容进行了转义，但在现在的场景中，我们并不需要它的转义（如果取消React默认的XSS保护，那么就需要仰仗于我们引入的库具有XSS保护或者我们手动处理），这时我们可以这样：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> converter = <span class="keyword">new</span> Showdown.converter();</span><br><span class="line"><span class="keyword">var</span> Comment = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 通过this.props.children访问元素的子元素</span></span><br><span class="line">        <span class="keyword">var</span> rawHtml = converter.makeHtml(<span class="keyword">this</span>.props.children.toString());</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">// 通过this.props访问元素的属性</span></span><br><span class="line">            <span class="comment">// 不转义，直接插入纯HTML</span></span><br><span class="line">            &lt;div className=<span class="string">"comment"</span>&gt;</span><br><span class="line">                &lt;h2 className=<span class="string">"commentAuthor"</span>&gt;&#123;<span class="keyword">this</span>.props.author&#125;&lt;/h2&gt;</span><br><span class="line">                &lt;span dangerouslySetInnerHTML=&#123;&#123;__html: rawHtml&#125;&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>好了，接下来我们的CommentList算是完成了，我们需要加上CommentForm组件让我们可以提交评论：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">CommentForm</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">    handleSubmit: function(e) &#123;</span><br><span class="line"> </span><br><span class="line">        e.preventDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> author = this.refs.author.getDOMNode().value.trim();</span><br><span class="line">        <span class="keyword">var</span> text = this.refs.text.getDOMNode().value.trim();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!text || !author) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        // <span class="type">TODO</span> 修改commentList</span><br><span class="line"> </span><br><span class="line">        // 获取原生<span class="type">DOM</span>元素</span><br><span class="line">        this.refs.author.getDOMNode().value = '';</span><br><span class="line">        this.refs.text.getDOMNode().value = '';</span><br><span class="line">    &#125;,</span><br><span class="line">    render: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            // 为元素添加submit事件处理程序</span><br><span class="line">            // 用<span class="keyword">ref</span>为子组件命名，并可以在this.refs中引用</span><br><span class="line">            &lt;form className=<span class="string">"commentForm"</span> onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">                &lt;input <span class="keyword">type</span>=<span class="string">"text"</span> placeholder=<span class="string">"Your name"</span> <span class="keyword">ref</span>=<span class="string">"author"</span>/&gt;</span><br><span class="line">                &lt;input <span class="keyword">type</span>=<span class="string">"text"</span> placeholder=<span class="string">"Say something..."</span> <span class="keyword">ref</span>=<span class="string">"text"</span>/&gt;</span><br><span class="line">                &lt;input <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"Post"</span>/&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从以上的代码中我们可以发现，我们可以为我们的组件添加事件处理程序，比如在这里我们需要利用form的submit事件，于是直接在标签上添加<code>onSubmit</code>的属性即可。需要注意的是，事件属性需要满足驼峰命名规则，也就是说如果是要添加click事件，那就要添加<code>onClick</code>，以此类推。还有一点就是我们需要获取两个文本框中的内容，这里使用的方法是在<code>input</code>标签上添加<code>ref</code>属性，这样就可以认为这个<code>input</code>是它的一个子组件，然后就可以通过访问<code>this.refs</code>来访问到这个子组件了，通过调用<code>getDOMNode</code>方法可以获取原生的DOM对象进行相应的操作。</p>
<p>我们发现到现在为止，我们的页面是静态的，但我们希望可以在成功提交了评论后可以立刻在评论列表中看到自己的评论，并可以每隔一段时间获取最新的评论，也就是说我们希望我们的CommentBox可以动态地改变状态。</p>
<p>首先我们先让CommentBox组件可以通过AJAX请求（在这里我用setTimeout来模拟获取数据的延迟），从服务器端获取评论数据同时更新CommentList。React组件有一个私有的<code>this.state</code>属性用于保存组件可变状态的数据，但一开始我们需要的是一个初始的状态，初始状态可以通过设置组件的<code>getInitialState</code>方法，它的返回值即为状态初始值。这个时候我们不是从标签的属性上直接获取数据了，需要通过访问<code>this.state</code>来获取（这个<code>state</code>属性如果直接用javascript访问会返回<code>undefined</code>，但可以在JSX中可以像<code>this.state.data</code>这样使用）：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;data: []&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"commentBox"</span>&gt;</span><br><span class="line">        &lt;h1&gt;Comments&lt;/h1&gt;</span><br><span class="line">        &lt;CommentList data=&#123;<span class="keyword">this</span>.state.data&#125; /&gt;</span><br><span class="line">        &lt;CommentForm /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接下来我们需要获取评论数据，我们可以在组件的<code>componentDidMount</code>方法中实现，这个方法会在组件呈现在页面上之后会被立刻调用一次，我们就在这个方法中获取到数据后更新下组件的状态，要更新组件的状态需要调用组件的<code>this.setState</code>方法，于是我们就这样写：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</span><br><span class="line">    <span class="comment">// 在组件的生命周期中仅执行一次，用于设置初始状态</span></span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;data: []&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    loadCommentsFromServer : <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 动态更新state</span></span><br><span class="line">            self.setState(&#123;data: comments&#125;);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当组件render完成后自动被调用</span></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.loadCommentsFromServer();</span><br><span class="line">        setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"commentBox"</span>&gt;</span><br><span class="line">                &lt;h1&gt;Comments&lt;/h1&gt;</span><br><span class="line">                &lt;CommentList data=&#123;<span class="keyword">this</span>.state.data&#125; /&gt;</span><br><span class="line">                &lt;CommentForm /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在我们已经可以更新评论列表里的数据了，那么同样的我们在CommentForm中成功提交的评论也要可以在CommentList中呈现出来，在这里需要注意的是我们现在设置的初始状态是CommentBox这个组件的，修改状态也是修改的CommentBox的状态，那么如果要在CommentForm中改变CommentBox的状态，就需要在CommentBox组件中通过标签属性的方式传递一个方法给子组件CommentForm，让CommentForm组件中的<code>handleSubmit</code>可以调用这个方法（也就是上面TODO的位置），于是我们的代码就是这样的：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</span><br><span class="line">    <span class="comment">// 在组件的生命周期中仅执行一次，用于设置初始状态</span></span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;data: []&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    onCommentSubmit: <span class="function"><span class="keyword">function</span><span class="params">(comment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟提交数据</span></span><br><span class="line">        comments.push(comment);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 动态更新state</span></span><br><span class="line">            self.setState(&#123;data: comments&#125;);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    loadCommentsFromServer : <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 动态更新state</span></span><br><span class="line">            self.setState(&#123;data: data&#125;);</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当组件render完成后自动被调用</span></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.loadCommentsFromServer();</span><br><span class="line">        setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">// 并非是真正的DOM元素，是React的div组件，默认具有XSS保护</span></span><br><span class="line">            &lt;div className=<span class="string">"commentBox"</span>&gt;</span><br><span class="line">                &lt;h1&gt;Comments&lt;/h1&gt;</span><br><span class="line">                &lt;CommentList data=&#123;<span class="keyword">this</span>.state.data&#125; /&gt;</span><br><span class="line">                &lt;CommentForm onCommentSubmit=&#123;<span class="keyword">this</span>.onCommentSubmit&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> CommentForm = React.createClass(&#123;</span><br><span class="line">    handleSubmit: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="comment">// e.returnValue = false;</span></span><br><span class="line">        <span class="keyword">var</span> author = <span class="keyword">this</span>.refs.author.getDOMNode().value.trim();</span><br><span class="line">        <span class="keyword">var</span> text = <span class="keyword">this</span>.refs.text.getDOMNode().value.trim();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!text || !author) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.props.onCommentSubmit(&#123;author: author, text: text&#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取原生DOM元素</span></span><br><span class="line">        <span class="keyword">this</span>.refs.author.getDOMNode().value = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">this</span>.refs.text.getDOMNode().value = <span class="string">''</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">// 为元素添加submit事件处理程序</span></span><br><span class="line">            <span class="comment">// 用ref为子组件命名，并可以在this.refs中引用</span></span><br><span class="line">            &lt;form className=<span class="string">"commentForm"</span> onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"Your name"</span> ref=<span class="string">"author"</span>/&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"Say something..."</span> ref=<span class="string">"text"</span>/&gt;</span><br><span class="line">                &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Post"</span>/&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>到此为止，我们的CommentBox组件就大功告成了，实例<a href="http://7sbm5t.com1.z0.glb.clouddn.com/react0_ex.html" target="_blank" rel="external">链接</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文是在阅读学习了官方的<a href="http://facebook.github.io/react/docs/tutorial.html">React Tutorial</a>之后的整理，实例<a href="http://7sbm5t.com1.z0.glb.clouddn.com/react0_ex.html">链接</a>。</p>
<h2 id="开始使用React">开始使用React</h2><p>首先从官方获取React.js的最新版本（<a href="http://facebook.github.io/react/downloads.html">v0.12.2</a>），或者下载官方的<a href="http://facebook.github.io/react/downloads/react-0.12.2.zip">Starter Kit</a>，并在我们的html中引入它们：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>React Test Page<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../build/react.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../build/JSXTransformer.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="JSX语法">JSX语法</h2><p>我们可以在React组件的代码中发现xml标签似乎直接写进了javascript里：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React.render(</span><br><span class="line">    &lt;CommentBox /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这种写法被称作JSX，是React的一个可选功能，将xml标签直接写在javascript中看上去比调用javascript方法要更加直观些。要正常使用这个功能，需要在你的页面中引入<code>JSXTransformer.js</code>文件，或者使用<code>npm</code>安装<code>react-tools</code>，将包含JSX语法的源文件编译成常规的javascript文件，比较推荐的是后者，因为使用后者让页面可以直接使用编译后的javascript文件而不需要在加载页面时进行JSX编译。</p>
<p>JSX中的类HTML标签并不是真正的HTML元素，也不是一段HTML字符串，而是实例化了的React组件，关于JSX语法的更多内容，可以看这篇文章。</p>]]>
    
    </summary>
    
      <category term="react.js" scheme="http://leozdgao.github.io/tags/react-js/"/>
    
      <category term="JS类库探索" scheme="http://leozdgao.github.io/categories/jslibs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IP协议]]></title>
    <link href="http://leozdgao.github.io/2015/02/17/IP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://leozdgao.github.io/2015/02/17/IP协议/</id>
    <published>2015-02-17T03:31:08.000Z</published>
    <updated>2015-03-21T03:35:59.065Z</updated>
    <content type="html"><![CDATA[<h2 id="IP网际协议">IP网际协议</h2><p>IP（IPv4，IPv6） 相应于OSI参考模型中的第三场——网络层。<br>网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>
<p><strong>主机</strong>是指配置有IP地址，但是不进行路由控制的设备。<br><strong>路由器</strong>是指既配有IP地址又具有路由控制能力的设备。<br><strong>节点</strong>是主机和路由器的统称。</p>
<h2 id="IP基础知识">IP基础知识</h2><p>IP地址用于在连接到网络中的所有主机中识别出进行通信的目标地址。</p>
<p><strong>路由控制</strong>是指将分组发送到最终目标地址的功能。IP路由也叫做多跳路由，是指路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到最终目标地址为止的所有通路全都指定出来。当某个IP包到达路由器时，路由器首先查找其目标地址，从而再决定下一步应该将这个包发往哪个路由器，然后将包发送过去。<strong>路由控制表</strong>记录IP数据在下一步应该发给哪个路由器。</p>
<p>不同的数据链路具有不同的<strong>最大传输单位</strong>（MTU：Maximum Transmission Unit）。如果数据包大于数据链路的MTU，IP将进行分片处理（IP Fragmentation），将较大的IP包分成多个较小的IP包。分片的包到了对端目标地址以后会再被组合起来传给上一层。</p>
<p>IP面向无连接，在发包之前，不需要建立对端目标地址之间的连接。</p>
<a id="more"></a>
<h2 id="IP地址基础知识">IP地址基础知识</h2><p>IP地址（IPv4地址）由32位正整数来表示，最多可以允许43亿台计算机连接到网络，每一台主机上的每一块网卡（NIC）都得设置IP地址。</p>
<p>IP地址由<strong>网络标识</strong>和<strong>主机标识</strong>两部分组成，IP包被转发到途中某个路由器时，正是利用目标IP地址的网络标识进行路由。最初二者以分类进行区别，现在基本以<strong>子网掩码</strong>区分。</p>
<p>IP地址的分类：</p>
<ul>
<li>A类地址：首位以“0”开头的地址，从第1位到第8位是它的网络标识。</li>
<li>B类地址：前两位为“10”的地址，从第1位到第16位是它的网络标识。</li>
<li>C类地址：前三位为“110”的地址，从第1位到第24位是它的网络标识。</li>
<li>D类地址：前四位为“1110”的地址，从第1位到第32位是它的网络标识，没有主机标识，常被用于多播。</li>
</ul>
<p>要用比特位标识主机地址时，不可以全部为0或全部为1。全部为0只有在表示对应的网络地址或IP地址不可货值的情况下才使用。全部为1的主机地址通常作为广播地址。</p>
<p>现在一个IP地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个<strong>子网掩码</strong>的识别码通过子网网络地址细分出更小粒度的网络。引入子网后，一个IP地址有两种识别码，一是IP地址本身，另一个是表示网络部的子网掩码，它对应网络标识部分的位全部为“1”，对应IP地址主机标识的部分则全部为“0”。</p>
<p>CIDR（无类型域间选路）：采用任意长度分割IP地址的网络标识和主机标识，网络内部采用固定长度的子网掩码机制。<br>VLSM（可变长子网掩码）：可以随机修改组织内各个部门的子网掩码长度的机制。</p>
<p>私有网络IP地址：</p>
<ol>
<li>10/8（A类）</li>
<li>172.16/16（B类）</li>
<li>192.168/16（C类）</li>
</ol>
<p>配有私有IP的地址主机连网时，则通过NAT进行通信。</p>
<p>在世界范围内，全局IP由ICANN（互联网名称与数字地址分配机构 ）进行管理。</p>
<h2 id="路由控制">路由控制</h2><p>在数据发送过程中保存指明路由器或主机信息的是<strong>路由控制表</strong>。路由控制表记录者网络地址与下一步应该发送至路由器的地址。</p>
<p>默认路由：0.0.0.0/0（default）指路由表中任何一个地址都能与之匹配的记录。<br>主机路由：“IP地址/32” Host Route<br>环回地址：127.0.0.1（localhost）同一台计算机上的程序之间惊醒网络通信时所用，数据包不会流向网络。</p>
<h2 id="IP分割处理与再构成处理">IP分割处理与再构成处理</h2><p>任何一台主句都有必要对IP分片进行相应的处理。经过分片之后IP数据包重组只能由目标主机进行。</p>
<p><strong>路径MTU发现</strong>是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小，即路径中存在的所有数据链路中最小的MTU。<br>工作原理：首先在发送端主机发送IP数据报时将其首部的分片禁止标志位设置为1，随后通过一个ICMP的不可达消息将数据链路上MTU的值给发送主机，发送主机根据这个MTU对数据报进行分片处理，如此反复，知道数据包被发送到目标主机为止没有再收到任何ICMP，就认为最后一次ICMP所统治的MTU即使一个合适的MTU值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="IP网际协议">IP网际协议</h2><p>IP（IPv4，IPv6） 相应于OSI参考模型中的第三场——网络层。<br>网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>
<p><strong>主机</strong>是指配置有IP地址，但是不进行路由控制的设备。<br><strong>路由器</strong>是指既配有IP地址又具有路由控制能力的设备。<br><strong>节点</strong>是主机和路由器的统称。</p>
<h2 id="IP基础知识">IP基础知识</h2><p>IP地址用于在连接到网络中的所有主机中识别出进行通信的目标地址。</p>
<p><strong>路由控制</strong>是指将分组发送到最终目标地址的功能。IP路由也叫做多跳路由，是指路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到最终目标地址为止的所有通路全都指定出来。当某个IP包到达路由器时，路由器首先查找其目标地址，从而再决定下一步应该将这个包发往哪个路由器，然后将包发送过去。<strong>路由控制表</strong>记录IP数据在下一步应该发给哪个路由器。</p>
<p>不同的数据链路具有不同的<strong>最大传输单位</strong>（MTU：Maximum Transmission Unit）。如果数据包大于数据链路的MTU，IP将进行分片处理（IP Fragmentation），将较大的IP包分成多个较小的IP包。分片的包到了对端目标地址以后会再被组合起来传给上一层。</p>
<p>IP面向无连接，在发包之前，不需要建立对端目标地址之间的连接。</p>]]>
    
    </summary>
    
      <category term="计算机网络基础" scheme="http://leozdgao.github.io/categories/net/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据链路]]></title>
    <link href="http://leozdgao.github.io/2015/02/16/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF/"/>
    <id>http://leozdgao.github.io/2015/02/16/数据链路/</id>
    <published>2015-02-16T03:32:04.000Z</published>
    <updated>2015-03-21T03:35:27.236Z</updated>
    <content type="html"><![CDATA[<h2 id="数据链路的作用">数据链路的作用</h2><p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。</p>
<h2 id="数据链路相关技术">数据链路相关技术</h2><ol>
<li><p>MAC地址<br>MAC地址用于识别数据链路中互连的节点。MAC地址长48比特，在使用网卡（NIC）的情况下，MAC地址一般会被烧入到ROM中。MAC地址中3~24位表示厂商识别码，25~48位是厂商内部为识别每个网卡而用。因此可以保证全世界不会用相同MAC地址的网卡。</p>
</li>
<li><p>共享介质型网络<br>多个设备共享一个通信介质的一种网络。</p>
<ul>
<li>争用方式（CSMA）</li>
<li>令牌传递方式</li>
</ul>
</li>
<li><p>非共享介质网络<br>不共享介质，对介质采用专用的一种传输控制方式。在这种方式下，网络中的每个站直连交换机，由交换机负责转发数据帧。该方式可以根据交换机的高级特性构建虚拟局域网（VLAN）、进行流量控制等。但一旦交换机发生故障，与之相连的所有计算机之间都将无法通信。</p>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p>MAC地址转发<br>以太网交换机就是持有多个端口的网桥。它们根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表就叫<strong>转发表</strong>。数据链路层的每个通过点在接到包时，会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中。（自学过程）</p>
<ul>
<li>存储转发</li>
<li>直通转发</li>
</ul>
</li>
<li><p>环路检测技术</p>
<ul>
<li>生成树方式</li>
<li>源路由法</li>
</ul>
</li>
<li><p>VLAN 虚拟局域网<br>交换机按照其端口区分了多个网段，从而区分了广播数据传播的范围、减少了网络负载并提高了网络的安全性。</p>
</li>
</ol>
<h2 id="以太网（Ethernet）">以太网（Ethernet）</h2><p>在以太网普及之初，一般采用多台终端使用同一根同轴电缆的共享介质型连接方式。现在一般采用终端与交换机之间独占电缆的方式实现以太网通信。</p>
<p><strong>以太网帧格式</strong>：以太网前端有一个叫做前导码的部分，由0、1数字交替组合而成，表示一个以太网帧的开始。前导码末尾是一个叫做SFD的域，值是“11”。前导码与SFD合起来占8个字节。以太网本体的前端是以太网的首部，它总共占14个字节。分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。紧随帧头后面的是数据。一个数据帧最大数据范围是46~1500个字节。帧尾是一个叫做FCS（Frame Check Sequence）的4个字节。</p>
<p>数据链路层分为两层：</p>
<ul>
<li>介质访问控制层 MAC（Media Access Control）</li>
<li>逻辑链路控制层 LLC（Logical Link Control）</li>
</ul>
<h2 id="无线通信">无线通信</h2><p>无线通信通常使用电磁波、红外线、激光等方式传播数据。</p>
<p>IEEE802.11定义了无线LAN协议中无历程与数据链路层的一部分（MAC层）</p>
<h2 id="PPP">PPP</h2><p>点对点，1对1连接计算机的协议。</p>
<p>PPP的主要功能中包括两个协议：</p>
<ul>
<li>LCP（Link Control Protocol）：负责建立和断开连接、设置最大接收单元、设置验证协议（PAP、CHAP）以及设置是否进行通信质量的监控。</li>
<li>NCP（Network Control Protocol）：依赖上层协议，如果上层为IP协议，NCP也叫做IPCP，负责IP地址设置以及是否进行TCP/IP首部压缩等设置。</li>
</ul>
<p>PPP连接时通常需要进行用户名密码的验证，并且对通信两端进行双方向的验证：</p>
<ul>
<li>PAP（Password Authentication Protocol）：通过两次握手进行用户名和密码验证，密码以明文方式传输。</li>
<li>CHAP（Challenge Handshake Authentication Protocol）：使用一次性密码（OTP），连接后还进行定期的密码交换，用来校验对端是否中途被替换。</li>
</ul>
<p>PPP帧格式：在每个帧的前后加上8位字节的标志码“01111110”以区分帧。两个标志码中不允许连续6个以上的“1”，当连续出现5个“1”时后面必须插入一个0，接收端如果收到连续5个“1”并且后面跟着的是0，就必须删除。</p>
<p>PPPoE（PPP over Ethernet）： 在以太网上提供PPP功能。单纯的以太网没有建立和断开连接的处理，采用PPPoE管理以太网连接，就可以利用PPP的验证等功能使各家ISP有效地管理终端用户的使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="数据链路的作用">数据链路的作用</h2><p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。</p>
<h2 id="数据链路相关技术">数据链路相关技术</h2><ol>
<li><p>MAC地址<br>MAC地址用于识别数据链路中互连的节点。MAC地址长48比特，在使用网卡（NIC）的情况下，MAC地址一般会被烧入到ROM中。MAC地址中3~24位表示厂商识别码，25~48位是厂商内部为识别每个网卡而用。因此可以保证全世界不会用相同MAC地址的网卡。</p>
</li>
<li><p>共享介质型网络<br>多个设备共享一个通信介质的一种网络。</p>
<ul>
<li>争用方式（CSMA）</li>
<li>令牌传递方式</li>
</ul>
</li>
<li><p>非共享介质网络<br>不共享介质，对介质采用专用的一种传输控制方式。在这种方式下，网络中的每个站直连交换机，由交换机负责转发数据帧。该方式可以根据交换机的高级特性构建虚拟局域网（VLAN）、进行流量控制等。但一旦交换机发生故障，与之相连的所有计算机之间都将无法通信。</p>
</li>
</ol>]]>
    
    </summary>
    
      <category term="计算机网络基础" scheme="http://leozdgao.github.io/categories/net/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP/IP基础知识]]></title>
    <link href="http://leozdgao.github.io/2015/02/15/TCP-IP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://leozdgao.github.io/2015/02/15/TCP-IP基础知识/</id>
    <published>2015-02-15T03:32:50.000Z</published>
    <updated>2015-03-21T03:36:15.710Z</updated>
    <content type="html"><![CDATA[<h2 id="TCP/IP的诞生">TCP/IP的诞生</h2><table>
<thead>
<tr>
<th>年份</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>20世纪60年代后半叶</td>
<td>应DoD要求，美国开始进行通信技术相关的研发。</td>
</tr>
<tr>
<td>1969年</td>
<td>ARPANET诞生。开发分组交换技术。</td>
</tr>
<tr>
<td>1972年</td>
<td>ARPANET取得初步成功。扩展到50个节点。</td>
</tr>
<tr>
<td>1975年</td>
<td>TCP/IP诞生。</td>
</tr>
<tr>
<td>1982年</td>
<td>TCP/IP规范出炉。UNIX是最早开始实现TCP/IP的协议。</td>
</tr>
<tr>
<td>1983年</td>
<td>ARPANET决定正式启用TCP/IP为通信协议。</td>
</tr>
<tr>
<td>1989年左右</td>
<td>局域网上的TCP/IP应用迅速扩大。</td>
</tr>
<tr>
<td>1990年左右</td>
<td>不论是局域网还是广域网，都开始倾向于使用TCP/IP。</td>
</tr>
<tr>
<td>1995年左右</td>
<td>互联网开始商用，互联网服务供应商的数量剧增。</td>
</tr>
<tr>
<td>1996年</td>
<td>IPv6规范出炉，载入RFC。（后于1998年修订）</td>
</tr>
</tbody>
</table>
<p><strong>ISP</strong>互联网接入服务提供商 Internet Service Provider</p>
<a id="more"></a>
<h2 id="TCP/IP的标准化">TCP/IP的标准化</h2><p>TCP/IP协议是指利用IP进行通信时所必须摇动的协议群的统称。</p>
<p>TCP/IP协议由IETF讨论制定，并被列入RFC文档。对某个协议的扩展或修改都将废除老的RFC，重新发行一个新的RFC文档。</p>
<p>TCP/IP的标准化流程：</p>
<ul>
<li>互联网草案阶段</li>
<li>记入RFC进入提议标准阶段</li>
<li>草案标准阶段</li>
<li>正式成为标准</li>
</ul>
<h2 id="互联网基础知识">互联网基础知识</h2><p><strong>互联网</strong>是指由ARPANET发展而来、互连全世界的计算机网络。TCP/IP原本就是为使用互联网而制定的协议族。因此，互联网的协议就是TCP/IP，TCP/IP就是互联网的协议。</p>
<p><strong>NOC</strong> 网络操作中心 Network Operation Center</p>
<p><strong>IX</strong> 网络交换中心 Internet Exchange</p>
<p>互联网就是众多异构的网络通过IX互连的一个巨型网络。</p>
<h2 id="TCP/IP协议分层模型">TCP/IP协议分层模型</h2><ol>
<li><p>硬件（物理层）<br>负责数据传输的硬件，没有既定的标准</p>
</li>
<li><p>网络接口层（数据链路层）<br>利用以太网中的数据链路层进行通信，可以把它当作让NIC（网卡）起作用的“驱动程序”</p>
</li>
<li><p>互联网层（网络层）<br>使用IP协议，基于IP地址转发分包数据。IP、ICMP、ARP。</p>
</li>
<li><p>传输层<br>主要功能是让应用程序之间实现通信。TCP、UDP。</p>
</li>
<li><p>应用层（会话层以上的分层）<br>WWW（Web浏览器上网 HTTP）、Email（电子邮件 SMTP）、FTP（文件传输）、TELNET与SSH（远程登录）、SNMP（网络管理）</p>
</li>
</ol>
<h2 id="TCP/IP分层模型通信实例">TCP/IP分层模型通信实例</h2><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息。在下一层的角度看，从上一分层收到的包全部都被认为是本层的数据。</p>
<p>首先应用程序中会进行编码处理，随后建立TCP连接，利用这个TCP连接发送数据。TCP提供将应用层发来的数据顺利发送至对端的可靠传输，TCP首部中包括源端口号和目标端口号、序号以及校验和。IP将TCP传来的TCP首部和TCP数据合起来做自己的数据。IP首部中包含接收端IP地址以及发送端IP地址，还有用来判断其后面是TCP还是UDP的信息。从IP传来的IP包，以太网驱动给这数据附上以太网首部，包含接收端MAC地址、发送端MAC地址以及标志以太网类型的以太网数据的协议。</p>
<p>每个包首部中之后会包含两个信息：一个是<strong>发送端和接收端地址</strong>，另一个是<strong>上一次的协议类型</strong>。经过每个协议分层时，都必须有识别包发送端和接收端的信息，以太网会用MAC地址，IP会用IP地址，而TCP/UDP则会用端口号作为识别两端主机的地址。</p>
<p>主机接受到以太网包以后，首先从以太网首部找到MAC地址半段是否为发送给自己的包，如果不是则丢弃数据。之后判断上层协议类型，交给相应的子程序处理，比如处理IP的子程序。IP模块检查目标IP地址是否与自己的IP地址匹配，之后交由TCP或UDP子程序处理，如果是路由器，需要借助路由控制表再转发数据。在TCP模块中，首先会计算校验和，判断数据是否被破坏，然后检查是否按照序号接受数据，最后检查端口号，确定具体应用程序。数据就收完毕后，就手段则发送一个“确认回执”给发送端。如果这个回执信息未能送达发送端，那么发送端会认为接收端没有收到数据而一直反复发送。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="TCP/IP的诞生">TCP/IP的诞生</h2><table>
<thead>
<tr>
<th>年份</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>20世纪60年代后半叶</td>
<td>应DoD要求，美国开始进行通信技术相关的研发。</td>
</tr>
<tr>
<td>1969年</td>
<td>ARPANET诞生。开发分组交换技术。</td>
</tr>
<tr>
<td>1972年</td>
<td>ARPANET取得初步成功。扩展到50个节点。</td>
</tr>
<tr>
<td>1975年</td>
<td>TCP/IP诞生。</td>
</tr>
<tr>
<td>1982年</td>
<td>TCP/IP规范出炉。UNIX是最早开始实现TCP/IP的协议。</td>
</tr>
<tr>
<td>1983年</td>
<td>ARPANET决定正式启用TCP/IP为通信协议。</td>
</tr>
<tr>
<td>1989年左右</td>
<td>局域网上的TCP/IP应用迅速扩大。</td>
</tr>
<tr>
<td>1990年左右</td>
<td>不论是局域网还是广域网，都开始倾向于使用TCP/IP。</td>
</tr>
<tr>
<td>1995年左右</td>
<td>互联网开始商用，互联网服务供应商的数量剧增。</td>
</tr>
<tr>
<td>1996年</td>
<td>IPv6规范出炉，载入RFC。（后于1998年修订）</td>
</tr>
</tbody>
</table>
<p><strong>ISP</strong>互联网接入服务提供商 Internet Service Provider</p>]]>
    
    </summary>
    
      <category term="计算机网络基础" scheme="http://leozdgao.github.io/categories/net/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络基础知识]]></title>
    <link href="http://leozdgao.github.io/2015/02/14/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://leozdgao.github.io/2015/02/14/网络基础知识/</id>
    <published>2015-02-14T03:33:45.000Z</published>
    <updated>2015-03-21T03:35:16.983Z</updated>
    <content type="html"><![CDATA[<h2 id="计算机与网络发展的7个阶段">计算机与网络发展的7个阶段</h2><table>
<thead>
<tr>
<th>年代</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>20世纪50年代</td>
<td>批处理时代</td>
</tr>
<tr>
<td>20世纪60年代</td>
<td>分时系统时代</td>
</tr>
<tr>
<td>20世纪70年代</td>
<td>计算机间通信时代</td>
</tr>
<tr>
<td>20世纪80年代</td>
<td>计算机网络时代</td>
</tr>
<tr>
<td>20世纪90年代</td>
<td>互联网普及时代</td>
</tr>
<tr>
<td>2000年</td>
<td>以互联网为中心的时代</td>
</tr>
<tr>
<td>2010年</td>
<td>无论何时何地一切皆TCP/IP的网络时代</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="协议">协议</h2><p><strong>协议</strong>就是计算机与计算机之间通过网络实现通信时实现达成的一种“约定”。</p>
<p><strong>ISO</strong>：国际标准化组织 International Organization for Standards</p>
<p><strong>OSI</strong>：开放式通信系统互联参考模型 Open Systems Interconnection</p>
<p>OSI参考模型</p>
<table>
<thead>
<tr>
<th></th>
<th>分层名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>应用层</td>
<td>针对特定应用的协议</td>
</tr>
<tr>
<td>6</td>
<td>表示层</td>
<td>设备固有数据格式和网络标准数据格式的转换</td>
</tr>
<tr>
<td>5</td>
<td>会话层</td>
<td>通信管理。负责建立和断开通信连接</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
<td>管理两个节点之间的数据传输。负责可靠传输</td>
</tr>
<tr>
<td>3</td>
<td>网络层</td>
<td>地址管理与路由选择</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层</td>
<td>互连设备之间传送和识别数据帧</td>
</tr>
<tr>
<td>1</td>
<td>物理层</td>
<td>以”0“、”1“代表电压的高低、灯光的闪灭。界定连接器和网线的规格</td>
</tr>
</tbody>
</table>
<h2 id="传输方式分类">传输方式分类</h2><ul>
<li>面向有连接 TCP</li>
<li>面向无连接 UDP、IP       </li>
</ul>
<p><strong>电路交换</strong>，计算机通过电路建立连接后，计算机之间的通信会独占整个线路。</p>
<p><strong>分组交换</strong>是指将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。计算机通信会在每一个分组中附加上源主机地址和目标主机地址送给通信线路，这些发送端地址、接收端地址以及分组序号写入的部分称为<strong>报文首部</strong>。</p>
<p>在分组交换中，由分组交换机（<strong> 路由器</strong>）连接通信线路。路由器接收到数据后会按照顺序缓存到相应的队列当中，再以先进先出的顺序将它们逐一发送出去。</p>
<p>根据接收端数量分类</p>
<ul>
<li>单播（Unicast）</li>
<li>广播（Broadcast）</li>
<li>多播（Multicast）</li>
<li>任播（Anycast）</li>
</ul>
<h2 id="地址">地址</h2><p>TCP/IP通信中使用MAC地址、IP地址、端口号</p>
<ul>
<li>唯一性</li>
<li>层次性</li>
</ul>
<p>MAC地址和IP地址在标识一个通信主体时虽然都具有唯一性，但是它们中只有IP地址具有层次性</p>
<h2 id="网络的构成要素">网络的构成要素</h2><table>
<thead>
<tr>
<th>设备</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>网卡（网络适配器）</td>
<td>使计算机连网的设备（Network Interface）</td>
</tr>
<tr>
<td>中继器（Repeater）</td>
<td>从物理层上延长网络的设备</td>
</tr>
<tr>
<td>网桥（Bridge）/2层交换机</td>
<td>从数据链路层上延长网络的设备</td>
</tr>
<tr>
<td>路由器（Router） /3层交换机</td>
<td>通过网络层转发分组数据的设备</td>
</tr>
<tr>
<td>4~7层交换机</td>
<td>处理传输层以上各层网络传输的设备</td>
</tr>
<tr>
<td>网关（Gateway）</td>
<td>转换协议的设备</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="计算机与网络发展的7个阶段">计算机与网络发展的7个阶段</h2><table>
<thead>
<tr>
<th>年代</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>20世纪50年代</td>
<td>批处理时代</td>
</tr>
<tr>
<td>20世纪60年代</td>
<td>分时系统时代</td>
</tr>
<tr>
<td>20世纪70年代</td>
<td>计算机间通信时代</td>
</tr>
<tr>
<td>20世纪80年代</td>
<td>计算机网络时代</td>
</tr>
<tr>
<td>20世纪90年代</td>
<td>互联网普及时代</td>
</tr>
<tr>
<td>2000年</td>
<td>以互联网为中心的时代</td>
</tr>
<tr>
<td>2010年</td>
<td>无论何时何地一切皆TCP/IP的网络时代</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="计算机网络基础" scheme="http://leozdgao.github.io/categories/net/"/>
    
  </entry>
  
</feed>