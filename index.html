<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Leo.Gao</title>
  <meta name="author" content="Leo Gao">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Leo.Gao"/>

  
    <meta property="og:image" content="undefined"/>
  
  <meta name="baidu-site-verification" content="KFPqVnQyRU" />
  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Leo.Gao" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Leo.Gao</a></h1>
  <h2><a href="/">不积跬步无以至千里</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">文章列表</a></li>
    
      <li><a href="/about">关于作者</a></li>
    
      <li><a href="/atom.xml">RSS</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-06-08T12:29:34.000Z"><a href="/2015/06/08/【译】解构ReactJS的Flux/">2015-06-08</a></time>
      
      
  
    <h1 class="title"><a href="/2015/06/08/【译】解构ReactJS的Flux/">【译】解构ReactJS的Flux</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="用ReactJS时不要使用MVC">用ReactJS时不要使用MVC</h2><p>我将通过列出一些单向数据流的例子来将ReactJS官方实现的<a href="https://github.com/facebook/flux">Flux</a>和我写的库<a href="https://github.com/spoike/refluxjs">Reflux</a>作比较。</p>
<p>Facebook的ReactJS开发小组似乎并不待见MVC框架。将MVC模式和ReactJS结合使用了一段时间后，我似乎发现了争议从何而来了。你会遇到一个问题：你应该如何处理数据？ReactJS并不在乎太多关于数据是如何传入的或者贯穿整个Web应用去处理数据。这个几乎是一个架构层面的问题，并不是ReactJS所能涵盖的。于是Facebook中的优秀开发者提出了一个函数式的方法，他们称其为：<strong>Flux</strong>。</p>
<p><strong>Flux</strong>的基本思想是可以在Web应用中拥有一个更加函数式的方法来处理数据。<strong>Flux</strong>介绍了Actions和Data Stores的概念来处理整个应用的事件和数据。数据流大致是这个样子的：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action <span class="subst">-&gt; </span><span class="built_in">Data</span> Store <span class="subst">-&gt; </span>Component</span><br></pre></td></tr></table></figure>
<p>数据的突变必须是在调用Actions时发生的，Data Stores需要监听actions并且改变store中的数据。这让数据结构保持扁平，并让数据的改变操作始终发生在Stores中，这防止了让Components自己处理数据所带来的副作用。</p>
<p>通过使用单向数据流，跟踪数据的改变将更加容易，因为它完全依赖于actions是如何发布的，继而影响整个应用。Components自身仅通过执行调用action来改变应用数据，这样避免了维护上的麻烦。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/06/08/【译】解构ReactJS的Flux/#more" class="more-link">更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-22T15:52:49.000Z"><a href="/2015/05/22/vertical-align属性与垂直居中/">2015-05-22</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/22/vertical-align属性与垂直居中/">vertical-align属性与垂直居中</a></h1>
  

    </header>
    <div class="entry">
      
        <p>让元素居中对齐是非常常见的需求，首先是水平居中，要实现水平居中行内元素只需要在其父元素上设置<code>text-align: center</code>即可，对于块级元素来说让它的<code>margin-left: auto</code>和<code>margin-right: auto</code>即可（width不可为auto），那么垂直居中呢？找下css属性发现了<code>vertical-align</code>，感觉就是它了，设置个<code>vertical-align: middle</code>，怎么没有达到预期效果？下面来详细介绍下<code>vertical-align</code>这个属性以及实现垂直居中的若干方法。</p>
<h2 id="vertical-align属性是干什么的">vertical-align属性是干什么的</h2><p>根据<a href="http://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align">W3C Spec</a>中对<code>vertical-align</code>属性的定义：</p>
<blockquote>
<p>This property affects the vertical positioning inside a line box of the boxes generated by an inline-level element.</p>
</blockquote>
<p>什么是line box？同样来自<a href="http://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#inline-formatting">W3C Spec</a></p>
<blockquote>
<p>The rectangular area that contains the boxes that form a line is called a line box.</p>
</blockquote>
<p>这个属性仅影响了单行中行内元素的垂直位置，那么我们会涉及到的元素应该是这样的：</p>
<ul>
<li><p>inline</p>
</li>
<li><p>inline-block</p>
</li>
</ul>
<p>既然我们要垂直居中，垂直居中是相对于垂直高度而言的，然而我们知道<code>height</code>对inline元素无效，那么line box的高度是怎么计算的呢？（还是引用W3C Spec）</p>
<blockquote>
<p>The height of a line box is determined by the rules given in the section on line height calculations.</p>
</blockquote>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/05/22/vertical-align属性与垂直居中/#more" class="more-link">更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-14T09:49:17.000Z"><a href="/2015/05/14/BOM中计算元素相关尺寸或偏移量的方式汇总/">2015-05-14</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/14/BOM中计算元素相关尺寸或偏移量的方式汇总/">BOM中计算元素相关尺寸或偏移量的方式汇总</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="元素尺寸">元素尺寸</h2><p>获取元素的尺寸（Dimension），该尺寸为该元素border-box的大小<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">rect</span> = element.getBoundingClientRect();  <span class="comment">// return ClientRect object</span></span><br><span class="line">var <span class="variable">height</span> = <span class="built_in">rect</span>.bottom - <span class="built_in">rect</span>.top;</span><br><span class="line">var <span class="variable">width</span> = <span class="built_in">rect</span>.right - <span class="built_in">rect</span>.left;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>clientHeight / clientWidth</td>
<td>用户可见高度 / 宽度（元素的padding-box高度 / 宽度 - 滚动条宽度）</td>
</tr>
<tr>
<td>scrollHeight / scrollWidth</td>
<td>元素的内容高度 / 宽度（包括元素的溢出部分）+padding</td>
</tr>
<tr>
<td>offsetHeight / offsetWidth</td>
<td>元素的border-box高度 / 宽度（包括元素的padding+border+滚动条+正文高度 / 宽度）</td>
</tr>
</tbody>
</table>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/05/14/BOM中计算元素相关尺寸或偏移量的方式汇总/#more" class="more-link">更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-10T14:46:13.000Z"><a href="/2015/04/10/拖放文件上传功能总结/">2015-04-10</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/10/拖放文件上传功能总结/">拖放文件上传功能总结</a></h1>
  

    </header>
    <div class="entry">
      
        <p>学习了下HTML5的拖放API，并做了一个拖放文件上传的Demo，server端使用了node.js，<a href="https://github.com/leozdgao/dndUpload">github地址</a></p>
<h2 id="拖放API">拖放API</h2><p>在HTML5中，可以让DOM中的某个元素具有可拖放的属性，或者可以将浏览器外的文件拖放到浏览器中，并利用File API做一些后续的处理。先介绍下HTML5的拖放API。</p>
<p>要让DOM中的元素可拖放，需要设置该元素的<code>draggable</code>属性，并赋值为true，就像这样：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"demo"</span> draggable=<span class="string">"true"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>然后介绍下拖放相关的事件，这是我们主要用来实现拖放逻辑的东西。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>产生事件的对象</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dragstart</td>
<td>被拖放的元素</td>
<td>开始拖放操作</td>
</tr>
<tr>
<td>drag</td>
<td>被拖放的元素</td>
<td>在拖放的过程中</td>
</tr>
<tr>
<td>dragend</td>
<td>被拖放的元素</td>
<td>拖放操作结束</td>
</tr>
<tr>
<td>dragenter</td>
<td>拖放过程中鼠标经过的元素</td>
<td>被拖放的元素进入该元素</td>
</tr>
<tr>
<td>dragover</td>
<td>拖放过程中鼠标经过的元素</td>
<td>被拖放的元素在该元素中移动</td>
</tr>
<tr>
<td>dragleave</td>
<td>拖放过程中鼠标经过的元素</td>
<td>被拖放的元素离开该元素</td>
</tr>
<tr>
<td>drop</td>
<td>拖放的目标元素</td>
<td>拖放元素被放到了该元素上</td>
</tr>
</tbody>
</table>
<p>拖放操作说到底是一种数据交换的操作，即将被拖放元素上的数据传递到拖放目标上去，那么我就需要<code>dataTransfer</code>对象来做这个数据传递的工作。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/10/拖放文件上传功能总结/#more" class="more-link">更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-09T15:18:05.000Z"><a href="/2015/04/09/FormData对象/">2015-04-09</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/09/FormData对象/">FormData对象</a></h1>
  

    </header>
    <div class="entry">
      
        <p>兼容性：IE10+</p>
<p>FormData对象可以利用一些键值对来模拟表单控件的值，并在<code>XMLHttpRequest 2.0</code>中使用send方法来异步提交表单、上传文件。</p>
<p><strong>创建FormData</strong></p>
<p>通过<code>new</code>关键字调用构造器，构造器接受一个可选参数（HTMLFormElement），根据现有表单得到FormData：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> fData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line"><span class="reserved">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'my-form'</span>);</span><br><span class="line"><span class="reserved">var</span> oData = <span class="keyword">new</span> FormData(form);</span><br></pre></td></tr></table></figure>
<p><strong>为FormData添加数据</strong></p>
<p>FormData数据仅暴露出一个方法<code>append</code>，用于往FormData中追加数据，第一个参数为字符串，代表key，第二个参数为字符串、File对象或Blob对象，其他类型都会被转换为字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fData.<span class="built_in">append</span>(<span class="string">'key1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">fData.<span class="built_in">append</span>(<span class="string">'key2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">xhr.send(fData);</span><br></pre></td></tr></table></figure>
<p>当FormData中有File时，XMLHttpRequest的请求头中的<code>Content-Type</code>被自动设置为<code>multipart/form-data</code>。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-09T14:49:17.000Z"><a href="/2015/04/09/创建并触发自定义事件、模拟事件/">2015-04-09</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/09/创建并触发自定义事件、模拟事件/">创建并触发自定义事件、模拟事件</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文介绍了创建了使用原生JavaScript API创建事件对象并模拟触发事件的方法。</p>
<p><br></p>
<h2 id="创建自定义事件对象">创建自定义事件对象</h2><p>可以通过<code>Event</code>构造器来创建一个事件对象：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">event</span> = <span class="keyword">new</span> <span class="keyword">Event</span>(<span class="string">'build'</span>);</span><br></pre></td></tr></table></figure>
<p>在IE中，虽然有Event这个构造器，但是直接用<code>new</code>来构造会抛出异常，可以使用一个更老的方法，调用<code>document.createEvent</code>来创建一个事件对象并使用<code>e.initEvent</code>来初始化这个事件对象：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">event</span> = document.createEvent(<span class="string">'Event'</span>);</span><br><span class="line"><span class="keyword">event</span>.initEvent(<span class="string">'build'</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>第二个参数代表<em>bubbles</em>，表示事件是否可冒泡。第三个参数代表<em>cancelable</em>，表示事件是否可被取消（preventDefault）。</p>
<h2 id="触发事件">触发事件</h2><p>在事件目标对象（通常是一个HTMLElement）上调用<code>dispatchEvent</code>来触发某个事件，触发的事件由传递的事件对象决定， 比如触发上面自定义好的build事件：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">event</span> = document.createEvent(<span class="string">'Event'</span>);</span><br><span class="line"><span class="keyword">event</span>.initEvent(<span class="string">'build'</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">var</span> box = document.getElementById(<span class="string">'box'</span>);</span><br><span class="line">box.dispatchEvent(<span class="keyword">event</span>);</span><br></pre></td></tr></table></figure>
<p>也可以通过这个办法来模拟事件的触发，比如模拟<code>mouseenter</code>事件：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvent'</span>);</span><br><span class="line">e.initEvent(<span class="string">'mouseenter'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="reserved">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line">box.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-03-23T14:15:44.000Z"><a href="/2015/03/23/ECMAScript-6新增功能——块级作用域与解构赋值/">2015-03-23</a></time>
      
      
  
    <h1 class="title"><a href="/2015/03/23/ECMAScript-6新增功能——块级作用域与解构赋值/">ECMAScript 6新增功能——块级作用域与解构赋值</a></h1>
  

    </header>
    <div class="entry">
      
        <p>根据<a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a>学习了ES6的一些新特性，在io.js v1.61版本进行代码测试，部分代码需要打开了<code>--harmony</code>，<code>--use_strict</code>等flag。</p>
<p>这个系列将将会有如下内容</p>
<ul>
<li>let , const以及块级作用域</li>
<li>变量的解构赋值</li>
<li>新增的方法</li>
<li>Set和Map数据结构</li>
<li>Generator函数</li>
<li>Promise对象</li>
<li>Class和Module</li>
</ul>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/03/23/ECMAScript-6新增功能——块级作用域与解构赋值/#more" class="more-link">更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-03-21T11:36:13.000Z"><a href="/2015/03/21/Javascript语言精粹笔记整理/">2015-03-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/03/21/Javascript语言精粹笔记整理/">Javascript语言精粹笔记整理</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这两天读了一下《Javascript语言精粹》一书，没有想象中的惊艳，不过在薄薄的100多页中浓缩了许多Javascript的编程技巧，值得细细品味。于是做了该笔记，算是对Javascript知识体系的一个回顾和整理，但并没有把书中的代码直接copy&amp;paste，而是对技巧的罗列，其中对继承那部分，有一些自己的理解。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/03/21/Javascript语言精粹笔记整理/#more" class="more-link">更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-03-17T12:55:13.000Z"><a href="/2015/03/17/CSS-Reset及相关思考/">2015-03-17</a></time>
      
      
  
    <h1 class="title"><a href="/2015/03/17/CSS-Reset及相关思考/">CSS Reset及相关思考</a></h1>
  

    </header>
    <div class="entry">
      
        <p>有一个专门讲CSS Reset的站点。 <a href="http://www.cssreset.com/">site</a></p>
<p>由于各大浏览器的user agent样式（即默认样式）不同，为了尽可能避免浏览器之间样式的差异，重置了css样式，让浏览器之间可以由一个基本相同的样式基准，并在该基准的基础上进行开发。</p>
<h2 id="引入CSS_Reset样式">引入CSS Reset样式</h2><p>引入CSS Reset，意味着告诉浏览器将所有元素应用上reset的样式，再使用针对页面或业务的特定样式。对于页面加载而言，这不算一个最优的方式，但对于组织css代码而言是一个好方法，因为页面针对不同浏览器都在一个统一的基准上开发。</p>
<p>而通常来说CSS Reset网上有许多现成的（可以去上面的链接里找），但直接引入或者直接复制黏贴不是推荐的做法，这里我直接引用：</p>
<blockquote>
<p>The reset styles given here are intentionally very generic. I don’t particularly recommend that you just use this in its unaltered state in your own projects. It should     be tweaked, edited, extended, and otherwise tuned to match your specific reset baseline. Fill in your preferred colors for the page, links, and so on. In other words, this is a starting point, not a self-contained black box of no-touchiness.</p>
</blockquote>
<p>简单地说，引入bootstrap后，即使html中没有定义任何class或者inline style，依然可以呈现出优雅的页面，即推荐大家根据自己的需求定制自己的CSS Reset，而不是直接拷贝（虽然确实省事）。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/03/17/CSS-Reset及相关思考/#more" class="more-link">更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-03-01T03:25:35.000Z"><a href="/2015/03/01/Shebang/">2015-03-01</a></time>
      
      
  
    <h1 class="title"><a href="/2015/03/01/Shebang/">Shebang</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="http://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="external">wiki</a>链接</p>
<p>在计算机科学中，Shebang（也称为Hashbang）是一个由井号和叹号构成的字符序列（<strong>#!</strong>），其出现在文本文件的第一行的前两个字符。 在文件中存在Shebang的情况下，类Unix操作系统的程序载入器会分析Shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有Shebang的文件路径作为该解释器的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span></span><br></pre></td></tr></table></figure>
<p>开头的文件在执行时会实际调用/bin/sh程序（通常是Bourne shell或兼容的shell，例如bash、dash等）来执行。</p>
<h2 id="语法">语法</h2><p>Shebang这一语法特性由<code>#!</code>开头，即井号和叹号。 在开头字符之后，可以有一个或数个空白字符，后接解释器的绝对路径，用于调用解释器。Shebang行也可以包含需要传递到解释器的特定选项。然而，选项传递的方式随实现的不同而不同。</p>
<p>使用<code>#!/usr/bin/env</code>脚本解释器名称是一种常见的在不同平台上都能正确找到解释器的办法。</p>
<p><strong>Node global bin</strong>：<code>#!/usr/bin/env node</code></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  




<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//baidu.com/baidu" method="get" accept-charset="utf-8">
    <input type="search" name="word" results="0" placeholder="搜索">
    <input type="hidden" name="si" value="site:leozdgao.github.io">
    <input name=tn type=hidden value="bds">
	<input name=cl type=hidden value="3">
	<input name=ct type=hidden value="2097152">
	<input name=s type=hidden value="on">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/HTML-CSS/">HTML/CSS</a><small>2</small></li>
  
    <li><a href="/categories/HTML5/">HTML5</a><small>1</small></li>
  
    <li><a href="/categories/jslibs/">JS类库探索</a><small>3</small></li>
  
    <li><a href="/categories/jsbasic/">Javascript基础</a><small>4</small></li>
  
    <li><a href="/categories/os/">操作系统基础</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li class="categories"><a href="/tags/BOM/">BOM</a><small>1</small></li>
  
    <li class="categories"><a href="/tags/ES6/">ES6</a><small>1</small></li>
  
    <li class="categories"><a href="/tags/css/">css</a><small>2</small></li>
  
    <li class="categories"><a href="/tags/git/">git</a><small>1</small></li>
  
    <li class="categories"><a href="/tags/javascript/">javascript</a><small>4</small></li>
  
    <li class="categories"><a href="/tags/linux/">linux</a><small>1</small></li>
  
    <li class="categories"><a href="/tags/react-js/">react.js</a><small>3</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 Leo Gao
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e1381102438d38c83d913131ba0400b0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</body>
</html>